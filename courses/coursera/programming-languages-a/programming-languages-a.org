* Syntax and Semantics
** Syntax is how you write something
** Semantics is what that something means
*** Type-checking (before program runs)
*** Evaluation (as program runs)
** For variable bindings
*** Type-check expression and extend static environment
*** Evaluate expression and extend dynamic environment
* Intro to ML
** Learning a Language involves Five Things
*** Syntax: How do you write language constructs?
*** Semantics: What do programs mean? (Evaluation rules)
*** Idioms: What are typical patterns to express your computation?
*** Libraries: What facilities does the language provide standard?
*** Tools: What is provided to make your job easier? (REPL, debugger, code formmatter, etc)
*** We will focus on semantics and idioms
**** Syntax is useful but mostly uninteresting
**** Libraries and tools are crucial, but often learned "on the job"
**** Without libraries and tools, our languages may look /silly/.
** Benefits of No Mutation
*** We can use aliases to existing data easily because of immutability
*** In languages with mutable data, programmers have to keep track of identity
**** Often crucial to make copies in correct places
**** Example: returning a copy of a mutable list
** Comments in ML with (* *)

#+BEGIN_SRC sml
(* This is a comment *)
#+END_SRC

** Create a variable with val

#+BEGIN_SRC sml
val x = 34;
(* static environment: x : int *)
(* dynamic environment: x --> 34 *)

val y = 17;
(* static environment: x : int, y : int *)
(* dynamic environment: x --> 34, y --> 17 *)

(* for more declarations, see 3_our_first_program.sml *)
#+END_SRC

** Top down. You cannot use later bindings; only earlier
** if is an expression: if e1 then e2 else e3;
*** e1 must be bool; e2 and e3 must be of the same type
*** you cannot leave off the else
*** no "truthiness".  e1 must be bool.
** End lines with semicolon in REPL, but not needed in file
** - is only used for subtraction; ~ for negation
** Functions are the most important building block in the course
*** Like Java methods, have arguments and result
*** But no classes, =this=, =return=, etc
*** Example

#+begin_src sml
(* Note: correct only if y>=0 *)

fun pow (x : int, y : int) =
  if y=0
  then 1
  else x * pow(x,y-1)

fun cube(x : int) =
  pow(x, 3)

(* functions of one argument can be called without parens *)
val sixtyfour = cube 4
#+end_src

** Tuples have a fixed "number of pieces" that may have different types
*** Pairs (2-tuples)
**** Access pieces with #1 e and #2 e

#+begin_src
val my_pair = (2, true)
val two = #1 my_pair
val t = #2 my_pair

fun swap (pr : int*bool) =
  (#2 pr, #1 pr)

val swapped_pair = swap my_pair

fun div_mod (x : int, y : int) =
  (x div y, x mod y)
#+end_src

*** Tuples
**** (e1,e2,...,en)
**** ta * tb * ... * tn
**** #1 e, #2 e, #3 e, ...
** List have any "number of pieces" that all have the same type
*** The empty list is a value: []
*** In general, a list of values is a value: [v1,v2,...,vn]
*** Cons: e1::e2 where e2 is a list and 1 is a compatible value

If e1 evaluates to v and e2 evaluates to a list [v1,...,vn]
  then e1::e2 evaluates to [v,...,vn]
  e1::e2 (* pronounced "cons" *)

*** Standard Library functions for Lists
**** =null e= evaluates to true iff e evaluates to []
***** null : 'a list -> bool
**** If e evaluates to [v1,v2,...,vn] then =hd e= evaluates to v1
***** Raises exception if e evaluates to []
***** hd : 'a list -> 'a
**** If e evaluates to [v1,v2,...,vn] then =tl e= evaluates to [v2,...,vn]
***** Raises exception if e evaluates to []
***** Notice result is a list
***** tl : 'a list -> 'a list
*** Type checking lists
**** For any type t, the type t list describes lists of t
**** Empty list has type 'a list.  The 'a is a type variable

The empty list is compatible with a list of any type!

**** List functions usually work on type 'a list

- null : 'a list -> bool
- hd : 'a list -> 'a
- tl : 'a list -> 'a list

**** We will pronounce 'a as alpha
*** Examples of functions on lists

#+begin_src sml
(* take a list and return an int *)
fun sum_list (xs : int list) =
    if null xs
    then 0
    else hd x + sum_list(tl xs)

(* take an int and return an int list *)
fun countdown (x : int) = 
    if x=0
    then []
    else x :: countdown(x-1)

(* take two int lists and return an int list *)
fun append (xs : int list, ys : int list) =
    if null xs
    then ys
    else hd x :: append(tl xs, ys)

(* function over list of pairs *)
fun sum_pair_list (xs : (int * int) list) =
    if null xs
    then 0
    else #1 (hd xs) + #2 (hd xs) + sum_pair_list(tl xs)
#+end_src

** let expressions can introduce local variables
*** =let b1 b2 ... bn in e end=
*** Basic let example

#+begin_src sml
(* silly1 : int -> int *)
fun silly1 (z : int) =
    let
        val x = if z > 0 then z else 34
        val y = x + z + 9
    in
        if x > y then x * 2 else y * y
    end

(* evaluates to 7 *)
fun silly2 () =
    let
        val x = 1
    in
        (let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
    end
#+end_src

*** let introduces *scope*
*** functions are just bindings, so let can introduce functions
**** nested functions are good style if they are:
***** unlikely to be useful elsewhere
***** likely to be misused if available elsewhere
***** likely to be changed or removed later
*** let expressions can prevent repeated computation

#+begin_src sml
(* the primary problem here is two recursive calls to bad_max *)
fun bad_max (xs : int list) =
    if null xs
    then 0  (* bad choice, but not what we're focused on *)
    else if null (tl xs)
    then hd xs
    else if hd xs > bad_max(tl xs)
    then hd xs
    else bad_max(tl xs)

(* let allows us to store the computation result *)
fun better_max (xs : int list) =
    if null xs
    then 0 (* still a bad choice *)
    else if null (tl xs)
    then hd xs
    else
        let val tl_ans = better_max(tl xs)
        in
            if hd xs > tl_ans
            then hd xs
            else tl_ans
        end
#+end_s
** Options can return NONE when a value is inappropriate
*** NONE or SOME e
*** NONE has type 'a option
*** SOME e has type t option if e has type t
*** access value with isSome and valOf
**** isSome : 'a option -> bool
**** valOf : 'a option -> 'a (exception if given NONE)
*** We saw in max where max [] shouldn't be 0
**** But what is max []?
***** an exception?
***** []
***** better answer: NONE

**** max with Options

#+begin_src sml
(* better_max :: int list -> int option *)
fun better_max (xs : int list) =
    if null xs
    then NONE
    else
        let val tl_ans = best_max(tl xs)
        in if isSome tl_ans andalso valOf tl_ans > hd xs
           then tl_ans
           else SOME (hd xs)
        end

(* even better; use an internal version without options *)
fun best_max (xs : int list) =
    if null xs
    then NONE
    else
        let fun max_nonempty (xs : int list) =
                if null (tl xs) (* we've already eliminated null xs *)
                then hd xs
                else let val tl_ans = max_nonempty(tl xs)
                     in
                         if hd xs > tl_ans
                         then hd xs
                         else tl_ans
                     end
        in
            SOME (max_nonempty xs)
        end
#+end_src

** Boolean Operations
*** orelse and andalso are like && and || in other langs
    
Note: for any programming language with if-else, orelse and
andalso are unnecessary (but convenient!)
 
*** not e1 is true if e1 is false; false if e1 is true
** Comparisons in ML

Comparison operators: = <> > < >= <=

Note: != is <>

You can compare two ints or two reals.  You can't compare an int
and a real.  You can convert an int to a real with =Real.fromInt=.
Real.fromInt 2 is 2.0.

You can use = and <> on any equality type.  However, reals are not
an equality type, so you cannot use = and <> with reals.

** Some ML Rules for Expressions
*** Variables

Syntax: sequence of letters, digits, _, not starting with a digit.

Type-checking: Look up type in current static environment or fail.

Evaluation: Look up value in current dynamic environment.
  Expressions in variable bindings are evaluated eagerly

*** Addition

Syntax: e1 + e2 where e1 and e2 are expressions.

Type-checking: if e1 and e2 have type int, then e1 + e2 have type int, or fail.

Evaluation: If e1 evaluates to v1 and e2 evaluates to v2,
  then e1 + e2 evaluates to the sum of v1 and v2.

*** Values

All values are expressions, but not all expressions are values.

Every value "evaluates to itself" in "zero steps".

Examples:
  34, 17, 52 have type int.
  true, false have type bool.
  () has type unit.

*** Conditional Expressions

Syntax: if e1 then e2 else e3, where if/then/else are keywords
  and e1, e2, e3 are sub-expressions.

Type-checking: e1 must be bool.  e2 and e3 can have any type t, but must have
  the same type t.  The type of the entire expression is t.

Evaluation: first evaluate e1 to a value v1.
  if v1 is true, then evaluate e2 and that is the whole expression's result.
  if v1 is false, then evaluate e3 and that is the whole expression's result.

*** Less-than

Syntax: e1 < e2

Type-checking: e1 and e2 must both be type t.  The whole expression is a bool.

Evaluation: first evaluate e1 and e2 to values v1 and v2, then compare v1 and v2

*** Functions

Syntax: fun x0 (x1 : t1, ... , xn : tn) = e

Type-checking: Adds binding x0 : (t1 * ... * tn) -> t if:
  Can type-check body e to have type t in the static environment
  containing:
    - "Enclosing" static environment (earlier bindings)
    - x1 : t1, ..., xn : tn (arguments with their types)
    - x0 : (t1 * ... * tn) -> t (for recursion)

Evaluation: A function is a value!
  - Adds x0 to dynamic environment so later expressions can call it
  - Function-call semantics will also allow recursion
Note: In SML there is no way to have functions that take variable # of args

*** Function Calls

Syntax: e0(e1, ..., en)
  Parentheses optional if there is exactly one argument

Type-checking:
  If:
    - e0 has some type (t1 * ... * tn) -> t
    - e1 has type t1, ..., en has type tn
  Then:
    - e0(e1,...,en) has type t

Evaluation:
  Under current dynamic environment, evaluate e0 to a function
    fun x0 (x1 : t1, ..., xn : tn) = e
    - Since call type-checked, result will be a function
  Under current dynamic environment, evaluate arguments to values v1, ..., vn
  Result is evaluation of e in an environment extended to map
    x1 to v1, ..., xn to vn
    - "An environment" is actually the environment where the function
      was defined, and includes x0 for recursion

*** Pairs (2-tuples)

Syntax: (e1,e2)

Type-checking: If e1 has type ta and e2 has type tb, then the pair has
  type ta * tb

Evaluation: Evaluate e1 to v1 and e2 to v2; result is (v1,v2)
  A pair of values is a value

*** let expressions

Syntax: let b1 b2 ... bn in e end
- Each bi is any binding and e is any expression

Type-checking: Type-check each bi and e in a static environment
  that includes the previous bindings.
  Type of whole let expression is the type of e.

Evaluation: Evaluate each bi and e in a dynamic environment
  that includes the previous bindings.
  Result of whole let-expression is result of evaluating e.

*** Boolean Operations

Two operations (three with not, but it's just a function)

Syntax: e1 andalso e2

Type-checking: e1 and e2 must have type bool

Evaluation: if result of e1 is false then false else result of e2

Syntax: e1 orelse e2

Type-checking: e1 and e2 must have type bool

Evaluation: if result of e1 is true then true else result of e2

=not= is just a function.  andalso and orelse do short-circuit evaluation,
so they aren't normal functions.

* Using the REPL
** You can type 'use filename.sml' to load a file
** Exit and restart session before using use again
** Errors
*** Syntax

What you wrote means nothing or not the construct you intended.

*** Type-checking

What you wrote does not type-check.

*** Evaluation

It runs but produces wrong answer, or an exception, or an infinite loop.
