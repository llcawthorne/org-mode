* I - Lisp is Power
** Getting Started with Lisp
*** Two main dialects of Lisp
**** Common Lisp; what this book will focus on
**** Scheme
*** Common Lisp is a multiparadigm language
*** Install CLISP to work along with book
*** If you make a mistake in the repl, just type :q
** Creating Your First Lisp Program
*** Create new top-level definitions (global vars) with =defparameter=

#+begin_src lisp
(defparameter *small* 1)
(defparameter *big* 100)
#+end_src
**** Name global variables with earmuffs: *foo*
**** =defparameter= will overwrite existing variables with the same name
**** Define global variables with =defvar= and it won't overwrite previous vars
*** Define functions with =defun=

#+begin_src lisp
(defun function_name (arguments)
  ...)
#+end_src
*** =ash= is the arithmetic shift function
**** (ash (+ *big* *small*) -1) is the average of *big* and *small*
**** it is commonly used for binary searches
*** =setf= is used to change the value of variable

#+begin_src lisp
(setf *big* (1- (guess-my-number)))

(setf *small* (1+ (guess-my-number)))
#+end_src
*** Define local variables with =let=

#+begin_src lisp
(let ((a 5)
      (b 6))
  (+ a b))
;; -> 11
#+end_src
*** Define local functions with =flet=

#+begin_src lisp
(flet ((f (n)
          (+ n 10))
       (g (n)
          (- n 3)))
  (g (f 5)))
;; -> 12
#+end_src
*** Make function names available in defined functions with =labels=

#+begin_src lisp
;; below function b calls a, so we needed labels
;; labels is also needed for recursion
(labels ((a (n)
            (+ n 5))
         (b (n)
            (+ (a n) 6)))
  (b 10))
;; -> 21
#+end_src
** Exploring the Syntax of Lisp Code
*** *Syntax* represents the rules needed to be followed to be valid in a language
**** Having simple syntax is a defining feature of Lisp
**** Parentheses are there to keep the amount of syntax to a minimum
*** *Semantics* is the meaning of something
**** You can write code with similar semantics (meaning) in most languages
*** Basic datatypes in Lisp
**** Symbols: any stand-alone word
***** letters, numbers, and characters like + = / * = < > ? ! _
***** case insensitive
**** Numbers: floating point or integer (based on decimal point present or not)
***** 1 and 1.0 are two different numbers
***** integers are upconverted to float in mixed math
***** division of integers returns a rational number
**** Strings: characters surrounded by double quotes
***** escape special characters (like ") with a backslash ("\"stop!\"")
*** Two reader modes
**** Code mode

The default mode of the reader.  Try to evaluate the head of a list as a
function applied to the rest of the list as arguments.  It also tries to
evaluate symbols, unless you prefix them with ' to enable data mode.

**** Data mode

Switch to data mode by prefixing with quote: '(1 2 3)

*** Lists in Lisp
**** cons

You can =cons= any item on to another, but you normally cons on to a list.
Note that both nil and 'nil act as the empty list.  nil is the list
terminator in Lisp.  When Lispers talk about using =cons=, they say
they are /consing/ something.

#+begin_src lisp
(cons 'chicken 'cat) ;; => (CHICKEN . CAT)
(cons 'chicken nil)  ;; => (CHICKEN)
(cons 'chicken ())   ;; => (CHICKEN)
(cons 'chicken '(1 2) ;; => (CHICKEN 1 2)
(cons 'chicken (cons 1 (cons 2 ()))) ;; => (CHICKEN 1 2)
#+end_src

A list is a series of cons cells containing and element of the list and
a pointer to the rest of the list.

**** car

=car= returns the head of a list.  It is also called =first=.
It basically takes the element out of the first cons cell and
removes the cell, leaving the rest of the list.

#+begin_src lisp
(car '(beef chicken)) ;; -> BEEF
#+end_src

**** cdr

=cdr= returns everything except the head of the list.  It is also called =rest=
It returns the rest of the list pointed to in the second part of the cons cell.

#+begin_src lisp
(cdr '(pork beef chicken)) ;; -> (BEEF CHICKEN)
(car (cdr '(pork beef chicken))) ;; -> BEEF
#+end_src
**** cadr, caddr, caaddr, and more

=cadr= returns the =car= of the =cdr= of a list. There are more combinations
of =car= and =cdr= defined standard.  Like =caddr=.  You can use any function
of the form c*r up to four levels deep.  =cadadr= is already defined (four
levels deep), but =cadadar= is not (five levels deep).

#+begin_src lisp
(cadr '(pork beef chicken)) ;; -> BEER
(caadr '((beef pork) (chicken sammich)) ;; -> CHICKEN
(cadddr '(beef pork chicken sammich) ;; -> SAMMICH
#+end_src
**** list

=list= is a convenience function that will create a list out of several items
without you having to manually cons it together.  the list is the same as if
you had defined it from multiple calls to =cons= or defined it literally with
a quote ' in front.

#+begin_src lisp
(list 'pork 'beef 'chicken) ;; -> (PORK BEEF CHICKEN)
#+end_src
**** you can nest lists

#+begin_src lisp
(car '((peas carrots tomatoes) (pork beef chicken)))
;; -> (PEAS CARROTS TOMATOES)
(cdr car '((peas carrots tomatoes) (pork beef chicken)))
;; -> (CARROTS TOMATOES)
(cdar '((pea carrots tomatoes) (pork beef chicken)))
;; -> (CARROTS TOMATOES)
(cddr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> (DUCK)
(caddr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> DUCK
(cddar '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> (TOMATOES)
(cadadr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> BEEF
#+end_src

* II - Lisp is Symmetry
** Make Decisions with Conditions
*** The Symmetry of nil and ()
**** Empty Equals False

In Clojure, we would have to check =null list= or =seq list= to get False.
Everything is "truthy" in Clojure except =nil= and =false=, but =nil= is not
just an alias for the empty list (although you can =cons= items on to =nil=
to start lists).

**** A list containing an item is True
**** A typical list-eating function

#+begin_src lisp
(defun my-length (list)
  (if list
    (1+ (my-length (cdr list)))
    0))
#+end_src

**** The Four Disguises of ()
***** '()
***** 'nil
***** nil
***** ()
***** Any value not equivalent to () is true
***** This doesn't work the same in Scheme (or Clojure)
*** The Conditionals: if and Beyond
**** =if= makes different things happen when conditions are true

#+begin_src lisp
(if (= (+ 1 2) 3)
    'yup
    'nope)
;; -> YUP

(if (oddp 5)
    'odd-number
    'even-number)
;; -> ODD_NUMBER

(if '()
    'the-list-has-stuff-in-it
    'the-list-is-empty)
;; -> THE-LIST-IS-EMPTY
#+end_src)

**** =if= is a /special form/; it doesn't evaluate both branches
**** to do more than one thing in a branch, sequence actions with =progn=

#+begin_src lisp
(defvar *number-was-odd* nil)

(if (oddp 5)
    (progn (setf *number-was-odd* t)
           'odd-number)
    'even-number)
;; -> ODD-NUMBER
> *number-was-odd*
;; -> T
#+end_src
**** =when= and =unless= contain a built-in =progn=

With =when=, all enclosed expressions are evaluated when the condition
is true.  With =unless=, all enclosed expressions are evaluated when the
condition is false.  Unlike =if=, there is no alternate branch.  They return
=nil= when the condition is the opposite value and do nothing.

#+begin_src lisp
(defvar *number-is-odd* nil)
(when (oddp 5)
      (setf *number-is-odd* t)
      'odd-number)
;; -> ODD-NUMBER
> *number-is-odd*
;; -> T

(unless (oddp 4)
        (setf *number-is-odd* nil)
        'even-number)
;; -> EVEN-NUMBER
> *number-is-odd*
;; -> NIL
#+end_src
**** the =cond= form is the classic way to do branching in Lisp

=cond= has a baked in =prog=, can handle more than one branch, and can
evaluate several conditions in succession. Note that it has more parentheses
than the Clojure version of =cond=.

#+begin_src lisp
(defvar *arch-enemy* nil)
(defun pudding-eater (person)
       (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
                                 '(curse you lisp alien - you at my pudding))
             ((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
                                  '(i hope you choked on my pudding johnny))
             (t                   '(why you eat my pudding stranger?))))
> (pudding-eater 'johnny)
;; -> (I HOPE YOU CHOKED ON MY PUDDING JOHNNY)
> *arch-enemy*
JOHNNY
#+end_src
**** =case= lets you supply a value to be compared with =eq=

Note: the case command uses =eq= for comparisons, so it is usually used
for branching on symbol values. It cannot be used to branch on string
values, among other things. We will look at comparing stuff with eq,
equal, and more later in the book.

#+begin_src lisp
(defun pudding-eater (person)
       (case person
             ((henry)   (setf *arch-enemy* 'stupid-lisp-alien)
                        '(curse you lisp alien - you ate my pudding))
             ((johnny)  (setf *arch-enemy* 'useless-old-johnny)
                        '(i hope you choked on my pudding johnny))
             (otherwise '(why you eat my pudding stranger?))))
#+end_src

**** =and= and =or= are stealth conditionals

=and= and =or= are simple mathematical operators that act as stealth
conditionals. Lisp uses /shortcut Boolean evaluation/, so that once it
determines the statement is true for =or= or false for =and=, it no longer
evaluates the remaining statements.

#+begin_src lisp
(and (oddp 5) (oddp 7) (oddp 9))
;; -> T
(or (oddp 4) (oddp 7) (oddp 8))
;; -> T

(defparameter *is-it-even* nil)
(or (oddp 4) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> T
(defparameter *is-it-even* nil)
(or (oddp 5) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> NIL

;; a real world example
(and *file-modified* (ask-user-about-saving) (save-file))
#+end_src

**** Using Functions That Return More than Just the Truth

Since any non-nil value evaluates to true, we often return something other
than true from functions.  =member= returns the rest of the list starting from
the matching item, and =find-if= returns the item it found.  An unfortunate
side effect of this is that you can't use =find-if= with =null= in a condition.

#+begin_src lisp
(member 1 '(3 4 1 5))
;; -> (1 5)
(if (member 1 '(3 4 1 5))
    'one-is-in-the-list
    'one-is-not-in-the-list)
;; -> 'ONE-IS-IN-THE-LIST

(find-if #'oddp '(2 4 5 6))
;; -> 5
(if (find-if #'oddp '(2 4 5 6))
    'there-is-an-odd-number
    'there-is-no-odd-number)
;; -> 'THERE-IS-AN-ODD-NUMBER
#+end_src

**** Comparing Stuff: eq, equal, and More
***** Conrad's Rule of Thumb for Comparing Stuff
****** Use =EQ= to compare symbols
****** Use =EQUAL= for everything else
***** Use =eq= to compare symbols
***** =equal= will tell you when two things "look the same"
***** =eql= compares symbols, numbers, and characters
***** =equalp= is like =equal= with a few twists

=equalp= can compare strings with different case, and it can compare
integers with floating point values.  Otherwise, it is like =equal=.

***** The remaining comparisons are like =equal= for certain datatypes

= only works for numbers, =string-equal= handles strings, =char-equal=
works for characters.

** Building a Text Game Engine
*** Functional Style

Functions written in a /functional programming/ style will reference only
parameters or variables declared in or passed to the function itself, and
will do nothing besides return a value. A function in this style will always
return the same result, as long as the same values are given as parameters.
In our game this chapter, =look= and =walk= are not functional because they
relies on or change global variables.

*** Association Lists

We'll talk about this a lot more in Chapter 7, but here's one in use:

#+begin_src lisp
(defparameter *nodes* '((living-room (you are in the living-room.
                                      a wizard is snoring loudly on the couch.))
                        (garden (you are in a beautiful garden.
                                 there is a well in front of you.))
                        (attic (you are in the attic.
                                there is a giant welding torch in the corner))))

(defun describe-location (location nodes)
  (cadr (assoc location nodes)))

(describe-location 'living-room *nodes*)
;; -> (YOU ARE IN A LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH).)
#+end_src

*** Quasiquoting

Quasiquoting allows you to create chunks of data that have small pieces
of Lisp code embedded in them. It uses ` and , Both the ' and ` flip us into
data mode, but ` can be unquoted using the , character to flip back to code
mode.

#+begin_src lisp
(defparameter *edges* '((living-room (garden west door)
                         (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))

(defun describe-path (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))
#+end_src

*** =mapcar=

=mapcar= will apply a function to every member of a list.

#+begin_src lisp
(mapcar #'car '((foo bar) (baz qux)))
;; -> (foo baz)

(mapcar #'describe-path '((GARDEN WEST DOOR) (ATTIC UPSTAIR LADDER)))
;; -> ((THERE IS A DOOR GOING WEST FROM HERE.))
;;     (THERE IS A LADDER GOING UPSTAIRS FROM HERE.))
#+end_src
*** #' is short-hand for the =function= operator

Unlike Scheme, Common Lisp has a namespace for functions and another for
variables. That's why we use #' to refer to a function name.  Because of
this difference in namespace, Scheme is a Lisp-1 and Common Lisp is a Lisp-2.

*** =apply= let's you give it a function and a list containing arguments

#+begin_src lisp
(apply #'append '((mary had) (a) (little lamb)))
;; -> (MARY HAD A LITTLE LAMB)
#+end_src
** Interacting with the World: Reading and Printing in Lisp
*** Printing and Reading Text
**** use =print= to print stuff to the console on its own line

=print= and =prin1= both print Lisp data structures. Strings are in quotes
and symbols are in all caps. Numbers look pretty normal. Characters look
like #\j.

**** multiple calls to =prin1= print stuff on the same line

The 1 means keep it on 1 line. Normal =print= precedes its output with a
newline and follows it with a space.

**** the =read= function lets the user enter something into the program

=read= reads Lisp data structures.  You need to surround strings with quotes.
A string without quotes is interpreted as a symbol. It will read numbers as
numbers or floats.

#+begin_src lisp
(defun say-hello ()
       (print "Please type your name:")
       (let ((name (read)))
            (print "Nice to meet you, ")
            (print name)))
#+end_src)

**** A character in lisp is #\j

Some special characters include #\newline, #\tab, and #\space

**** =princ= prints stuff for humans, it doesn't insert newline

=princ= leaves off the quotes from strings and the #\ from characters.

**** =read-line= reads a string as input, up to a newline

Read line will read the name as a string and take everything up to the newline
into the name variable.

#+begin_src lisp
(defun say-hello ()
       (princ "Please type your name:")
       (let ((name (read-line)))
            (princ "Nice to meet you, ")
            (princ name)))
#+end_src
*** The Symmetry Between Code and Data in Lisp
**** Lisp is /homoiconic/; it uses the same data structures for code and data
**** =eval= reads data as code

Warning: Inexperienced use of =eval= can pose a security risk!

#+begin_src lisp
;; let's store a chunk of data in a variable
(defparameter *foo* '(+ 1 2))
;; what if we want to execute that code.  =eval=
(eval *foo*)
;; -> 3
#+end_src

**** A Simple Custom REPL

A REPL literally only takes =read=, =eval=, =print=, and =loop=!
=read= reads the command as a symbol, =eval= evaluates it as a function,
=print= outputs what the function returns, loop makes it do it over and over.

#+begin_src lisp
(defun game-repl ()
  (loop (print (eval (read)))))
> (game-repl)
(look)

(YOU ARE IN THE LIVING-ROOM)...
#+end_src

**** A More Customized REPL
***** =game-repl=

Our goal is to be able to type "look" and "walk east" and do the game commands.
First we capture cmd using game-read, so we can see if the command is 'QUIT,
instead of making the user exit with Ctrl+C.  Then we eval and print, but
with custom versions we'll write shortly.  Finally, the game-repl calls itself.

#+begin_src lisp
(defun game-repl ()
  (let ((cmd (game-read)))
    (unless (eq (car cmd) 'quit)
      (game-print (game-eval cmd))
      (game-repl))))
#+end_src

***** =game-read=

=read= has two things we need to fix. First, we don't want to have to type
our command in parentheses, so we'll =read-line= a string then add our
parentheses afterwards. Also with read, we needed a quote in front of any
function commands. We should be able to type "walk east" without a quote
in front of east, so again, we'll take in a string and modify it by adding
the quote after the user enters it.

=read-from-string= works like =read= but it reads a syntax expression or other
Lisp datatype from a string instead of directly from the console. We are going
to tweak our string from =read-line= by =concatenate='ing quotes around it.
The result in =cmd= is that when someone types "walk east", we end up with
(walk east) in =cmd=. But we're going to pull off the =cdr= of =cmd= and map
=quote-it= across, so we end up with (walk 'east), which is what we had to
type in the REPL last chapter.  =(list 'quote 'east)= is equal to 'EAST.
(Unlike (list 'east), which equals (EAST)). We are quoting the raw parameter
by putting it in a list with =quote= command in front. =quote= is the head of
the list, so it gets evaluated to return 'EAST, which gets put back in our
initial list and gets the function call cons'ed on to the head of it.

#+begin_src lisp
(defun game-read ()
       (let ((cmd (read-from-string
                       (concatenate 'string "(" (read-line) ")"))))
       (flet ((quote-it (x)
                    (list 'quote x)))
            (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
> (game-read)
walk east
;; -> (WALK 'EAST)
#+end_src

***** =game-eval=

The main problem with =eval= is it would let the player run any Lisp command,
even one unrelated to the game. So we're going to write an =eval= that only
allows certain commands to be called.

#+begin_src lisp
(defparameter *allowed-commands* '(look walk pickup inventory))

(defun game-eval (sexp)
       (if (member (car sexp) *allowed-commands*)
           (eval sexp)
         '(i do not know that command.)))
#+end_src

***** =game-print=

Finally, let's get our output out of all uppercase, and out of parentheses.
First =prin1-to-string= will print our list of symbols to a string, then we'll
=string-trim= away the parentheses then coerce it to a list.  At this point it
looks something like this:

#+begin_src lisp
> (coerce (string-trim "() " (prin1-to-string '(a beautiful garden))) 'list)
;; -> (#\A #\Space #\B #\E #\A #\U #\T #\I #\F #\U #\L #\Space #\G #\A #\R #\D #\E #\N)
#+end_src

The only reason the list parentheses are there is because it is =coerce='d to a
list, and as you see it is a list of characters. We feed this to =tweak-text=
along with a t since the first letter should be capitalized and a =nil= for lit.
After =tweak-text= is done with it, we =coerce= it back to a string.  If we
were to =coerce= what we had above to a string without tweaking it, we would
get "A BEAUTIFUL GARDEN".

=tweak-text= processes our list of characters. It uses =cond= to check for
different conditions. First it checks if the char is a space and if so leaves
it unchanged and processes the next item. Next it checks if it is a sentence
terminator, and if so makes a not to capitalize the next character. If it's a
quote, we eliminate it and flip the lit parameter which interprets characters
literally and doesn't let us drop down to the capitalization rules. This let's
us handle some uncommon situations in our symbols, like "iPad" or "comma,".
When lit is set, it just =cons='s the unmodified char back on to the list.
Next we see if we have caps, and if so =cons= the =char-upcase= of the item on
to the rest of the list. And finally, for a normal character, we =cons= the
=char-downcase= of the item on to the rest of the list. I don't really
understand why we =or= caps and lit, since if lit was true, we wouldn't make it
to the =or= line. It seems like we only need to test caps.

#+begin_src lisp
(defun tweak-text (lst caps lit)
  (when lst
    (let ((item (car lst))
          (rest (cdr lst)))
      (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
            ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
            ((eq item #\") (tweak-text rest caps (not lit)))
            (lit (cons item (tweak-text rest nil lit)))
            ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
            (t (cons (char-downcase item) (tweak-text rest nil nil)))))))

(defun game-print (lst)
  (princ (coerce (tweak-text (coerce (string-trim "() "
                                                  (prin1-to-string lst))
                                     'list)
                             t
                             nil)
                 'string))
  (fresh-line))
#+end_src
**** The Dangers of =read= and =eval=

Despite us only executing functions from a whitelist, we are still vulnerable
to attacks involving reader macros. So as general advice, you should try not
to rely on =read= and =eval= in production Lisp code.

** Lambda: A Function So Important It Deserves Its Own Chapter
*** =lambda= lets you create a function without giving it a name
** Going Beyond Basic Lists
*** Dotted Lists

A list in Lisp that ends in something other than a =nil= is referred
to as a dotted list.

#+begin_src lisp
;; What if we cons a number onto another number instead of a list?
(cons 1 (cons 2 3))
;; -> (1 2 . 3)
#+end_src
*** Pairs

A pair is a dotted list of length 2.

#+begin_src lisp
(cons 2 3)
;; -> (2 . 3)
#+end_src

*** Circular Lists

The final cons cell of a list can point back at its head!

#+begin_src lisp
;; before playing with circular lists, run this
(setf *print-circle* t)

(defparameter foo '(1 2 3))
;; we're going to make an infinite list of (1 2 3 1 2 3 1 2 3 ...)
(setf (cdddr foo) foo)
;; -> #1=(1 2 3 . #1)#)
#+end_src

*** Association Lists (alists)

An alist consists of key/value pairs stored in a list.  By convention, if a key
appears multiple times in a list, it is assumed the first appearance of the key
contains the desired value.  Alists are commonly used but are not very efficient
for dealing with more than a dozen or so items, so are often replaced with
other data structures as a program matures.

#+begin_src lisp
(defparameter *drink-order* '((bill . double-espresso)
                              (lisa . small-drip-coffee)
                              (john . medium-latte)))
> (assoc 'lisa *drink-order*)
;; -> (LISA . SMALL-DRIP-COFFEE)

;; push adds an item to an alist.  first match is returned by assoc
(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
;; -> ((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
;;     (BILL . DOUBLE-ESPRESSO)
;;     (LISA . SMALL-DRIP-COFFEE)
;;     (JOHN . MEDIUM-LATTE))

> (assoc 'lisa *drink-order*)
;; -> (LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
#+end_src
*** Coping with Complicated Data
**** Visualizing Tree-like Data

Lists are elegant for storing trees.

#+begin_src lisp
(defparameter *house* '((walls (mortar (cement)
                                       (water)
                                       (sand))
                               (bricks))
                        (windows (glass)
                                 (frame)
                                 (curtains))
                        (roof (shingles)
                              (chimney))))
#+end_src

**** Visualizing Graphs

Graphs can be stored in cons cells, but they are difficult to visualize.  It's
hard to get a decent understanding of the structure of the game world from the
following:

#+begin_src lisp
(defparameter *wizard-nodes* '((living-room (you are in the living-room.
                                a wizard is snoring loudly on the couch.))
                               (garden (you are in a beautiful garden.
                                there is a well in front of you.))
                               (attic (you are in the attic.  there
                                is a giant welding torch in the corner.))))
(defparameter *wizard-edges* '((living-room (garden west door)
                                            (attic upstairs ladder))
                               (garden (living-room east door))
                               (attic (living-room downstairs ladder))))
#+end_src

***** Graphviz to the Rescue!
****** Converting Node Identifiers

A Graphviz identifier or a node can contain only letters, digits, and the
underscore character.  We'll replace non-alphanumeric characters with _.

#+begin_src lisp
(defun dot-name (exp)
  (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))

> (dot-name 'living-room)
;; -> "LIVING_ROOM"
> (dot-name 'foo!)
;; -> "FOO_"
#+end_src

****** Adding Labels to Graph Nodes

The label will consist of the node name and the data linked to the node in the
node alist.  We're going to limit it to 30 characters.

#+begin_src lisp
(defparameter *max-label-length* 30)

(defun dot-label (exp)
  (if exp
    (let ((s (write-to-string exp :pretty nil)))
      (if (> (length s) *max-label-length*)
             (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
          s))
    ""))
#+end_src

****** Generating the DOT Information for the Nodes

Now that we can generate a name and label for each node we can write a function
that takes an alist of nodes and generates the DOT information that encodes
them.  Note: =mapc= is like =mapcar= except it doesn't return the transformed
list.  We don't need the return value, since we're calling =princ=.

#+begin_src lisp
(defun nodes->dot (nodes)
  (mapc (lambda (node)
          (fresh-line)
          (princ (dot-name (car node)))
          (princ "[label=\"")
          (princ (dot-label node))
          (princ "\"];"))
    nodes))
#+end_src

****** Converting Edges into DOT Format

Next, we need DOT information for the edges that link our nodes.  They will
become the arrows in the output.

#+begin_src lisp
(defun edges->dot (edges)
  (mapc (lambda (node)
    (mapc (lambda (edge)
            (fresh-line)
            (princ (dot-name (car node)))
            (princ "->")
            (princ (dot-name (car edge)))
            (princ "[label=\"")
            (princ (dot-label (cdr edge)))
            (princ "\"];"))
          (cdr node)))
    edges))
#+end_src

****** Generating All the DOT Data

To complete our generation of the DOT data, we call both =nodes->dot= and
=edges->dot= and wrap it up with some extra decoration.

#+begin_src lisp
(defun graph->dot (nodes edges)
  (princ "digraph{")
  (nodes->dot nodes)
  (edges->dot edges)
  (princ "}"))
#+end_src

****** Turning the DOT File into a Picture

We are going to capture the DOT file data, put it into a file, then execute
the dot command through the command line.  It is common in Lisp to create
small functions that have zero arguments.  They are officially called
/nullary functions/.  Lispers will often create them in order to describe
a computation they don't want to run until later.  In this scenario, they are
commonly called a /thunk/ or a /suspension/.  In this case, the thunk is a
function that when called prints a DOT file to the console: =graph->dot=.
Because =graph->dot= prints directly to the console, we can't pass its return
value to =dot->png=, so instead we pass =graph->dot= as a thunk and =dot->png=
calls it, captures the results, and sends them to a file.  By calling our
stream we setup in =with-open-file= below *standard-output*, we capture output
to the console and redirect it to fname.

#+begin_src lisp
(defun dot->png (fname thunk)
  (with-open-file (*standard-output*
                   fname
                   :direction :output
                   :if-exists :supersede)
    (funcall thunk))
  (ext:shell (concatenate 'string "dot -Tpng -O " fname)))
#+end_src

****** Creating a Picture of Our Graph

Finally, we need a function that ties together all the pieces to let us
easily create a graph from some nodes and edges:

#+begin_src lisp
(defun graph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (graph->dot nodes edges))))
#+end_src)

****** Creating Undirected Graphs

It is also easy to create undirected graphs with Graphviz.  The following
code is similar to what we've seen, but makes an undirected graph.

#+begin_src lisp
(defun uedges->dot (edges)
  (maplist (lambda (lst)
             (mapc (lambda (edge)
                     (unless (assoc (car edge) (cdr lst))
                       (fresh-line)
                       (princ (dot-name (caar lst)))
                       (princ "--")
                       (princ (dot-name (car edge)))
                       (princ "[label=\"")
                       (princ (dot-label (cdr edge)))
                       (princ "\"];")))
               (cdar lst)))
    edges))

(defun ugraph->dot (nodes edges)
  (princ "graph{")
  (nodes->dot nodes)
  (uedges->dot edges)
  (princ "}"))

(defun ugraph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (ugraph->dot nodes edges))))
#+end_src)

** This Ain't Your Daddy's Wumpus
*** Intro to the Game

    "In this new version of Hunt the Wumpus, you are the Lisp alien. You and
    the Wumpus have just robbed a liquor store and made off with the loot.
    However, during the escape, the Wumpus decides to double-cross you and
    run off with the money and your car. But before he drives off, you manage
    to cap him a couple of times in the kidney.

    Now you’re in a pretty tough situation. You don’t have a car or any money,
    and no way to track down your former partner in crime. But you also have
    no choice. You have your principles, so you’re going to /hunt the Wumpus/."

*** Playing the Game

The game is in my git repo for land-of-lisp as wumpus.lisp.  To start, you
=(load "wumpus")= then type =(new-game)=.  Then you open the known-city.png in
the directory you ran it from.  This is your auto-updating map of the city.  To
explore a node, let's say Node 17, you type =(walk 17)=.  When you think you
know the Wumpus' location, you need to charge that node, like =(charge 23)= to
win the game.  Avoid glow-worms which show lights one node away and cops which
show up as sirens on the node adjacent to the edge with cops.  The Wumpus
leaves a blood trail two nodes away from his location, due to his injuries.
Don't cheat and look at the full city.png in the directory where you started
the new-game from.

*** Full Code in wumpus.lisp, but also spread out below
*** Defining the Edges of Congestion City

Congestion City will be an undirected graph of 30 nodes and 45 edges.

#+begin_src lisp
(load "graph-utils")

(defparameter *congestion-city-nodes* nil)
(defparameter *congestion-city-edges* nil)
(defparameter *visited-nodes* nil)
(defparameter *node-num* 30)
(defparameter *edge-num* 45)
(defparameter *worm-num* 3)
(defparameter *cop-odds* 15)

;; random *node-num* will give us a number from 0 to 29 for 30 nodes
;; so we're adding 1 to it to make it 1 to 30
(defun random-node ()
  (1+ (random *node-num*)))

(defun edge-pair (a b)
  (unless (eql a b)
    (list (cons a b) (cons b a))))

(defun make-edge-list ()
  (apply #'append (loop repeat *edge-num*
                               collect (edge-pair (random-node) (random-node)))))
#+end_src))

*** Looping with the =loop= Command

Within the =loop= comman, we specify how many times to =repeat=, and then
specify an object to collect with every loop.

#+begin_src lisp
(loop repeat 10
      collect 1)
;; -> (1 1 1 1 1 1 1 1 1 1)
(loop for n from 1 to 10
      collect n)
;; -> (1 2 3 4 5 6 7 8 9 10)
(loop for n from 1 to 10
      collect (+ 100 n))
;; -> (101 102 103 104 105 106 107 108 109 110)
#+end_src

*** Prevent Islands

If we randomly generate a graph, it might not be all connected.  This code
takes the list of edges, finds unconnected nodes, and connects these islands
to the rest of the city network.  First, we need =direct-edges=, a utility
function that finds all the edges in an edge list that start from a given node.
It does this by creating a new list with all edges removed that don't have the
current node in the =car= position.  To find islands we use =get-connected=,
which takes an edge list and a source node and builds a list of all nodes
connected to that node.  =find-islands= finds all our islands, and
=connect-with-bridges= returns a list of additional edges to connect our
islands together.  =connect-all-islands= ties all these together.  It appends
the bridges from =connect-with-bridges= to the main =edge-list=.

#+begin_src lisp
(defun direct-edges (node edge-list)
  (remove-if-not (lambda (x)
                   (eql (car x) node))
                 edge-list))

(defun get-connected (node edge-list)
  (let ((visited nil))
    (labels ((traverse (node)
               (unless (member node visited)
                 (push node visited)
                 (mapc (lambda (edge)
                         (traverse (cdr edge)))
                      (direct-edges node edge-list)))))
      (traverse node))
    visited))

(defun find-islands (nodes edge-list)
  (let ((islands nil))
    (labels ((find-island (nodes)
               (let* ((connected (get-connected (car nodes) edge-list))
                      (unconnected (set-difference nodes connected)))
                 (push connected islands)
                 (when unconnected
                   (find-island unconnected)))))
      (find-island nodes))
    islands))

(defun connect-with-bridges (islands)
  (when (cdr islands)
    (append (edge-pair (caar islands) (caadr islands))
            (connect-with-bridges (cdr islands)))))

(defun connect-all-islands (nodes edge-list)
  (append (connect-with-bridges (find-islands nodes edge-list)) edge-list))
#+end_src

*** Building the Final Edges for Congestion City

=make-city-edges= creates a list of nodes, then it creates a random (but fully
connected) edge list by calling =make-edge-list= and =connect-edge-list=.
It then creates a random list of edges that have cops.  We define these using
the =let*= command, which allows us to refer to previously defined variables
from the same =let*= block.

=edges-to-alist= converts a list of edges into an alist of edges.  For example,
let's say we had nodes 1, 2, and 3, with 1 connected to 2, 2 connected to 1 and
3, and 3 connected to 2.  As a list, this would be '((1 . 2) (2 . 1) (2 . 3)
(3 . 2)).  As an alist, this would be '((1 (2)) (2 (1) (3)) (3 (2))).  To build
this alist, =edges=to-list= first =mapcar=s over the nodes in the edge list.
It builds the list of nodes with =remove-duplicates=.  Within the outer =mapcar=
we do another =mapcar= to map across all the =direct-edges= to this node.
Together, these nested =mapcar= functions allow =edges-to-alist= to convert
the edges of a city into an alist.

=add-cops= marks the edges in our alist that contain cops.  It uses nested
=mapcar= commands to map across the edges within each node.  =intersection=
tell us if items are shared between two lists.  Imagine our three node city
again, where the alist is '((1 (2)) (2 (1) (3)) (3 (2))).  Now if we put cops
between 2 and 3, it would look like '((1 (2)) (2 (1) (3 COPS)) (3 (2 COPS))).
To get all edges connected to a given node, we call =(cdr (assoc node1 edges))=,
then to see if a given edge contains cops:
=(cdr (assoc node2 (cdr (assoc node1 edges))))=, which goes down two levels to
grab the actual data linked to a specific edge between two nodes.

#+begin_src lisp
(defun make-city-edges ()
  (let* ((nodes (loop for i from 1 to *node-num*
                      collect i))
         (edge-list (connect-all-islands nodes (make-edge-list)))
         (cops (remove-if-not (lambda (x)
                                (zerop (random *cop-odds*)))
                              edge-list)))
    (add-cops (edges-to-alist edge-list) cops)))

(defun edges-to-alist (edge-list)
  (mapcar (lambda (node1)
            (cons node1
                  (mapcar (lambda (edge)
                            (list (cdr edge)))
                          (remove-duplicates (direct-edges node1 edge-list)
                                             :test #'equal))))
          (remove-duplicates (mapcar #'car edge-list))))

(defun add-cops (edge-alist edges-with-cops)
  (mapcar (lambda (x)
            (let ((node1 (car x))
                  (node1-edges (cdr x)))
              (cons node1
                    (mapcar (lambda (edge)
                              (let ((node2 (car edge)))
                                (if (intersection (edge-pair node1 node2)
                                                  edges-with-cops
                                                  :test #'equal)
                                    (list node2 'cops)
                                    edge)))
                            node1-edges))))
          edge-alist))
#+end_src

*** Building the Nodes for Congestion City

Now we need an alist for the nodes in our city.  These nodes may contains the
Wumpus or the Glowworms, or they might contain various clues, such as blood,
lights, or sirens.  Most of the clues are based on proximity with another node.
The =neighbors= function looks up a node's neighbors.

#+begin_src lisp
(defun neighbors (node edge-alist)
  (mapcar #'car (cdr (assoc node edge-alist))))

(defun within-one (a b edge-alist)
  (member b (neighbors a edge-alist)))

(defun within-two (a b edge-alist)
  (or (within-one a b edge-alist)
      (some (lambda (x)
              (within-one x b edge-alist))
            (neighbors a edge-alist))))

(defun make-city-nodes (edge-alist)
  (let ((wumpus (random-node))
        (glow-worms (loop for i below *worm-num*
                          collect (random-node))))
    (loop for n from 1 to *node-num*
          collect (append (list n)
                          (cond ((eql n wumpus) '(wumpus))
                                ((within-two n wumpus edge-alist) '(blood!)))
                          (cond ((member n glow-worms)
                                 '(glow-worm))
                                ((some (lambda (worm)
                                         (within-one n worm edge-alist))
                                       glow-worms)
                                 '(lights!)))
                          (when (some #'cdr (cdr (assoc n edge-alist)))
                            '(sirens!)))))
#+end_src

*** Initializing a New Game of Grand Theft Wumpus

We need to only show city nodes we visited and hide cops before we explore.
=mapcan= is a variant of =mapcar= that assumes that the values generated by
the mapping function are all lists that should be appended together.

#+being_src lisp
(defun new-game ()
  (setf *congestion-city-edges* (make-city-edges))
  (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
  (setf *player-pos* (find-empty-node))
  (setf *visited-nodes* (list *player-pos*))
  (draw-city)
  (draw-known-city))

(defun find-empty-node ()
  (let ((x (random-node)))
    (if (cdr (assoc x *congestion-city-nodes*))
        (find-empty-node)
        x)))

(defun draw-city ()
  (ugraph->png "city" *congestion-city-nodes* *congestion-city-edges*)):w

(defun known-city-nodes ()
  (mapcar (lambda (node)
            (if (member node *visited-nodes*)
                (let ((n (assoc node *congestion-city-nodes*)))
                  (if (eql node *player-pos*)
                      (append n '(*))
                      n))
                (list node '?)))
          (remove-duplicates
           (append *visited-nodes*
                   (mapcan (lambda (node)
                             (mapcar #'car
                                     (cdr (assoc node *congestion-city-edges*))))
                           *visited-nodes*)))))

(defun known-city-edges ()
  (mapcar (lambda (node)
            (cons node (mapcar (lambda (x)
                                 (if (member (car x) *visited-nodes*)
                                     x
                                     (list (car x))))
                               (cdr (assoc node *congestion-city-edges*)))))
          *visited-nodes*))

(defun draw-known-city ()
  (ugraph->png "known-city" (known-city-nodes) (known-city-edges)))
#+end_src

*** Walking Around Town

Walk is used to move around.  You need to charge the final location of the
Wumpus to win the game, but if you charge any non-Wumpus location, you lose.

#+begin_src lisp
(defun walk (pos)
  (handle-direction pos nil))

(defun charge (pos)
  (handle-direction pos t))

(defun handle-direction (pos charging)
  (let ((edge (assoc pos (cdr (assoc *player-pos* *congestion-city-edges*)))))
    (if edge
        (handle-new-place edge pos charging)
        (princ "That location does not exist!"))))

(defun handle-new-place (edge pos charging)
  (let* ((node (assoc pos *congestion-city-nodes*))
         (has-worm (and (member 'glow-worm node)
                        (not (member pos *visited-nodes*)))))
    (pushnew pos *visited-nodes*)
    (setf *player-pos* pos)
    (draw-known-city)
    (cond ((member 'cops edge) (princ "You ran into the cops. Game Over."))
          ((member 'wumpus node) (if charging
                                     (princ "You found the Wumpus!")
                                     (princ "You ran into the Wumpus")))
          (charging (princ "You wasted your last bullet.  Game Over."))
          (has-worm (let ((new-pos (random-node)))
                      (princ "You ran into a Glow Worm Gang!  You're now at ")
                      (princ new-pos)
                      (handle-new-place nil new-pos nil))))))
#+end_src

** Advanced Datatypes and Generic Programming
*** Arrays
**** Advantage of arrays: constant-time random access
**** Working with Arrays

Use =aref= to get an set items in an array.  =aref= with =setf= to set.

#+begin_src lisp
(make-array 3)
;; -> #(NIL NIL NIL)
(defparameter x (make-array 3))
;; -> #(NIL NIL NIL)
;; get the item at index 1 with aref
(aref x 1)
;; -> NIL
(setf (aref x 1) 'foo)
;; -> FOO
x
;; -> #(NIL FOO NIL)
(aref x 1)
;; -> FOO
#+end_src

***** An aside on =setf=

Common Lisp supports /generic setters/.  In most cases, the code for pulling an
item out of a data structure is identical to code for putting data into that
structure.  The second argument to =setf= is a /generalized reference/, which
supports a fairly complicated subset of Lisp.

#+begin_src lisp
(setf foo '(a b c))
;; -> (A B C)
(second foo)
;; -> B
(setf (second foo) 'z)
;; -> Z
foo
;; -> (A Z C)
(setf foo (make-array 4))
;; -> #(NIL NIL NIL NIL)
(setf (aref foo 2) '(x y z))
;; -> (X Y Z)
foo
;; -> #(NIL NIL (X Y Z) NIL)
(setf (car (aref foo 2)) (make-hash-table))
;; -> #S(HASH-TABLE)
(setf (gethash 'zoink (car (aref foo 2))) 5)
;; -> 5
foo
;; -> #(NIL NIL (#S(HASH-TABLE (ZOINK . 5)) Y Z) NIL)
#+end_src

*** Hash Tables
**** Like alists, except faster arbitrary element access
**** Working with Hash Tables

You'll notice below that =gethash= returns two nils.  The first nil is the
actual value stored in the hash table.  The second nil indicates whether the
key was found in the table.

#+begin_src lisp
(defparameter x (make-hash-table))
;; -> #S(HASH-TABLE ...)
(gethash 'yup x)
;; -> NIL ;
;;    NIL
(setf (gethash 'yup x) '25)
;; -> 25
(gethash 'yup x)
;; -> 25 ;
;;    T
#+end_src

***** An aside on Returning Multiple Values

Some core Lisp functions like =gethash= and =round= return multiple values.
You can return multiple values too with the =values= function.  The first
value is more important and used in follow-up calculations.  If you need the
second value, you can bind it with =multiple-value-bind=.

#+begin_src lisp
(round 2.4)
;; -> 2 ;
;;    0.4
(defun foo ()
  (values 3 7))
;; -> FOO
(foo)
;; -> 3 ;
;;    7
;; the first value is "default"
(+ (foo) 5)
;; -> 8
;; but we can access both values
(multiple-value-bind (a b) (foo)
                     (* a b))
;; -> 21
#+end_src

**** A Faster Grand Theft Wumpus Using Hash Tables

alists were fine for our 30 node, 45 edge Grand Theft Wumpus, but if we tried
with 1000 nodes and 1000 edges, it would be a lot slower.  Here's the code to
convert our edge alist to a hash table.  As you see below, we can use =push=
on hash tables too.

#+begin_src lisp
(defun hash-edges (edge-list)
  (let ((tab (make-hash-table)))
    (mapc (lambda (x)
            (let ((node (car x)))
              (push (cdr x) (gethash node tab))))
      edge-list)
    tab))

;; now we need a new version of get-connected to use the hash
(defun get-connected-hash (node edge-tab)
  (let ((visited (make-hash-table)))
    (labels ((traverse (node)
               (unless (gethash node visited)
                 (setf (gethash node visited) t)
                 (mapc (lambda (edge)
                         (traverse edge))
                   (gethash node edge-tab)))))
      (traverse node))
    visited))
#+end_src

*** Performance Testing with =time=

The only true way to tell if changing a data structure or algorithm makes
your program faster is to time your code with the =time= command.

#+begin_src lisp
(setf *edge-num* 1000)
(setf *node-num* 1000)

(time (dotimes (i 100) (get-connected 1 (make-edge-list))))
;; takes almost 60 seconds with alists, barely 1 sec with hash tables
#+end_src

*** Common Lisp Structures
**** What are Structures?

Structures can be used to represent objects with properties.

#+begin_src lisp
(defstruct person
           name
           age
           waist-size
           favorite-color)
;; -> PERSON

;; defstruct automatically creates make-person
(defparameter *bob* (make-person :name "Bob"
                                 :age 35
                                 :waist-size 42
                                 :favorite-color "blue"))
;; -> *BOB*
*bob*
;; -> #S(PERSON :NAME "Bob" :AGE 35 :WAIST-SIZE 42 :FAVORITE-COLOR "blue")

;; we can get bob's age from person-age, also automatically generated
(person-age *bob*)
;; -> 35
(setf (person-age *bob*) 36)
;; -> 36

;; the reader can also create a person from the printed representation
(defparameter *that-guy* #S(person :name "Bob" :age 35 :waist-size 42 :favorite-color "blue"))
(person-age *that-guy*)
;; -> 35
#+end_src

**** When to Use Structures

There's nothing you can do with structures that you couldn't manage with lists
and some accessor functions.  However the accessor functions are error-prone,
and the list isn't self describing like a structure.  Structures also handle
mutation better, so are better for objects likely to change.

*** Handling Data in a Generic Way
**** Working with Sequences
***** Sequences: lists, arrays, and strings

Library functions often work well with multiple types of data.  For example,
the /sequence functions/ work generically across the three main ways of
sequencing objects in Lisp: lists, arrays, and strings.  =length= can take any
of those three and return its length.

***** Sequence Functions for Searching

=find-if= finds the first value that satisfies a predicate.
=count= finds out how often an object appears in a sequence.
=position= tells you where an item is located.
=some= and =every= tell you if some or every value in a sequence obey a
predicate.

#+begin_src lisp
(find-if #'numberp '(a b 5 d))
;; -> 5
(count #\s "mississippi")
;; -> 4
(position #\4 "2kewl4skewl")
;; -> 5
(some #'numberp '(a b 5 d))
;; -> T
(every #'numberp '(a b 5 d))
;; -> NIL
#+end_src

***** Sequence Functions for Iterating Across a Sequence

=reduce= allows you to iterate through a sequence and reduce it down to a
single result.  =map= is like =mapcar= but it works on any sequence.
You specify the type of sequence for =map= to return by passing an extra
argument to the =map= function.  =subseq= lets you pull a subsequence out
of a larger sequence by specifying starting and ending points.  The =sort=
function lets you pass it an arbitrary function to use for sorting.  These
functions are good to get you started.  For a more exhaustive list of functions,
refer to the [[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm][Common Lisp Hyperspec]].  It's complicated, but it has its own FAQ,
[[https://www.hexstreamsoft.com/articles/getting-started-with-the-clhs/][Getting started with the Common Lisp HyperSpec]].

#+begin_src lisp
(reduce #'+ '(3 4 6 5 2))
;; -> 20

(reduce (lambda (best item)
          (if (and (evenp item) (> item best))
            item
            best))
        '(7 4 6 5 2)
        :initial-value 0)
;; -> 6 ;; the greatest even item in the list

(map 'list
  (lambda (x)
    (if (eq x #\s)
      #\S
      x))
  "this is a string")
;; -> (“(#\t #\h #\i #\S #\  #\i #\S #\  #\a #\  #\S #\t #\r #\i #\n #\g)”

(subseq "america" 2 6)
;; -> "eric"

(sort '(4 8 2 4 9 3 6) #'<)
;; -> (2 3 4 5 6 8 9)
#+end_src)

**** Creating Your Own Generic Functions with Type Predicates and =defmethod=

You can tell what type a variable has with the type predicates.  The most
frequently used are: =arrayp=, =characterp=, =consp=, =functionp=,
=hash-table-p=, =listp=, =numberp=, =stringp=, and =symbolp=.

Here's a naive way to write an add function that works on lists or numbers.

#+begin_src lisp
;; this add works with numbers or lists
;; if we aren't given two numbers or two lists, the cond returns nil
(defun add (a b)
  (cond ((and (numberp a) (numberp b)) (+ a b))
        ((and (listp a) (listp b)) (append a b))))
;; -> ADD
(add 3 4)
;; -> 7
(add '(a b) '(c d))
;; -> (A B C D)
#+end_src

A better way to do the same is /type dispatching/ via =defmethod=.  We can
extend the results of =defmethod= to new types without modifying existing types,
and the logic isn't all based around one big =cond= test.  Also, it can be
better optimized by the Lisp compiler.  =defmethod= is like =defun=, but it
allows us to write multiple functions with the same name.  The combination of
=defmethod= and =defstruct= constitutes a simple object system.

#+begin_src lisp
(defmethod add ((a number) (b number))
  (+ a b))
;; -> ADD
(defmethod add ((a list) (b list))
  (append a b))
;; -> ADD
(add 3 4)
;; -> 7
(add '(a b) '(c d))
;; -> (A B C D)
#+end_src

*** The Orc Battle Game
**** Intro to the Game

     “In the Orc Battle game, you’re a knight surrounded by 12 monsters,
     engaged in a fight to the death. With your superior wits and your
     repertoire of sword-fighting maneuvers, you must carefully strategize in
     your battle with orcs, hydras, and other nasty enemies. One wrong move
     and you may be unable to kill them all before being worn down by their
     superior numbers. Using defmethod and defstruct, let’s dispatch some
     whoop ass on these vermin!”

**** Full Code in orc-battle.lisp
**** Initialize Some Variables

#+begin_src lisp
(defparameter *player-health* nil)
(defparameter *player-agility* nil)
(defparameter *player-strength* nil)
(defparameter *monsters* nil)
(defparameter *monster-builders* nil)
(defparameter *monster-num* 12)
#+end_src

**** Main Function and Basic Game Loop

#+begin_src lisp
(defun orc-battle ()
  (init-monsters)
  (init-player)
  (game-loop)
  (when (player-dead)
    (princ "You have been killed.  Game Over."))
  (when (monsters-dead)
    (princ "Congratulations!  You have vanquished all of your foes.")))

(defun game-loop ()
  (unless (or (player-dead) (monsters-dead))
    (show-player)
    (dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))
      (unless (monsters-dead)
        (show-monsters)
        (player-attack)))
    (fresh-line)
    (map 'list
         (lambda (m)
           (or (monster-dead m) (monster-attack m)))
         *monsters*)
    (game-loop)))
#+end_src

**** Player Management Functions

#+begin_src lisp
(defun init-player ()
  (setf *player-health* 30)
  (setf *player-agility* 30)
  (setf *player-strength* 30))

(defun player-dead ()
  (<= *player-health* 0))

(defun show-player ()
  (fresh-line)
  (princ "You are a valiant knight with a health of ")
  (princ *player-health*)
  (princ ", and agility of ")
  (princ *player-agility*)
  (princ ", and a strength of ")
  (princ *player-strength*))

(defun player-attack ()
  (fresh-line)
  (princ "Attack style: [s]tab [d]ouble swing [r]oundhouse: ")
  (case (read)
    (s (monster-hit (pick-monster)
                    (+ 2 (randval (ash *player-strength* -1)))))
    (d (let ((x (randval (truncate (/ *player-strength* 6)))))
         (princ "Your double swing has a strength of ")
         (princ x)
         (fresh-line)
         (monster-hit (pick-monster) x)
         (unless (monsters-dead)
           (monster-hit (pick-monster) x))))
    (otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))
                 (unless (monsters-dead)
                   (monster-hit (random-monster) 1))))))
#+end_src

**** Helper Functions for =player-attack=

We need a way to generate random values from 1 to n, a way to pick a random
monster, and a way to let the player select a monster.

#+begin_src lisp
(defun randval (n)
  (1+ (random (max 1 n))))

(defun random-monster ()
  (let ((m (aref *monsters* (random (length *monsters*)))))
    (if (monster-dead m)
        (random-monster)
        m)))

(defun pick-monster ()
  (fresh-line)
  (princ "Monster #: ")
  (let ((x (read)))
    (if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))
        (progn (princ "That is not a valid monster number.")
               (pick-monster))
        (let ((m (aref *monsters* (1- x))))
          (if (monster-dead m)
              (progn (princ "That monster is already dead.")
                     (pick-monster))
              m)))))
#+end_src

**** Monster Management Functions

#+begin_src lisp
(defun init-monsters ()
  (setf *monsters*
        (map 'vector
             (lambda (x)
               (funcall (nth (random (length *monster-builders*))
                                     *monster-builders*)))
               (make-array *monster-num*))))

(defun monster-dead (m)
  (<= (monster-health m) 0))

(defun monsters-dead ()
  (every #'monster-dead *monsters*))

(defun show-monsters ()
  (fresh-line)
  (princ "Your foes:")
  (let ((x 0))
    (map 'list
         (lambda (m)
           (fresh-line)
           (princ "    ")
           (princ (incf x))
           (princ ". ")
           (if (monster-dead m)
               (princ "**dead**")
               (progn (princ "(Health=")
                      (princ (monster-health m))
                      (princ ") ")
                      (monster-show m))))
         *monsters*)))
#+end_src

**** The Monsters (where we're using =defmethod= and =defstructure=!)
***** Note: There's cool pictures of all these monsters in the book!
***** The Generic Monster

All monsters have a health meter that determines how many hits they take
before they die.  When we declare a slot in a structure, we can put
parentheses around the name and add a default value for that slot.
=(defstruct monster (health (randval 10)))= declares a monster structure
that has a health property that defaults to a random value from 1 to 10.
Remember, defining this structure introduces a =make-monster= function to
create entities.  We're using =defmethod= for =monster-hit= and
=monster-show= so we can customize these for different types of monsters.
Note for our monster structure =(type-of m)= will be monster.  Also,
=monster-attack= is intentionally left empty, since the generic monster
doesn't have an attack.  We'll customize this for each monster.

#+begin_src lisp
(defstruct monster (health (randval 10)))

(defmethod monster-hit (m x)
  (decf (monster-health m) x)
  (if (monster-dead m)
      (progn (princ "You killed the ")
             (princ (type-of m))
             (princ "! "))
      (progn (princ "You hit the ")
             (princ (type-of m))
             (princ ", knocking off ")
             (princ x)
             (princ " health points! "))))

(defmethod monster-show (m)
  (princ "A fierce ")
  (princ (type-of m)))

;; intentionally left empty for the generic monster
(defmethod monster-attack (m))
#+end_src

***** The Wicked Orc

"The orc is a simple foe.  He can deliver a strong attack with his club,
but otherwise he is pretty harmless.  Every orc has a club with a unique
attack level.  Orcs are best ignored, unless there are orcs with an unusually
powerful club attack that you want to cull from the herd at the beginning of a
battle."

Notice how we include all the properties from our =monster= in our =orc=.  Also
notice that the orc relies on the generic monster =monster-hit= function rather
than defining one of its own.

#+begin_src lisp
(defstruct (orc (:include monster)) (club-level (randval 8)))
(push #'make-orc *monster-builders*)

(defmethod monster-show ((m orc))
  (princ "A wicked orc with a level ")
  (princ (orc-club-level m))
  (princ " club"))

(defmethod monster-attack ((m orc))
  (let ((x (randval (orc-club-level m))))
    (princ "An orc swings his club at you and knocks off ")
    (princ x)
    (princ " of your health points.  ")
    (decf *player-health* x)))
#+end_src

***** The Malicious Hydra

"The hydra is a very nasty enemy.  It will attack you with its many heads,
which you'll need to chop off to defeat it.  The hydra's special power is that
it can grow a new head during each round of battle, which means you want to
defeat it as early as possible."

#+begin_src lisp
(defstruct (hydra (:include monster)))
(push #'make-hydra *monster-builders*)

(defmethod monster-show ((m hydra))
  (princ "A malicious hydra with ")
  (princ (monster-health m))
  (princ " heads."))

(defmethod monster-hit ((m hydra) x)
  (decf (monster-health m) x)
  (if (monster-dead m)
      (princ "The corpse of the fully decapitated and decapacitated hydra falls to the floor!")
      (progn (princ "You lop off ")
             (princ x)
             (princ " of the hydra's heads! "))))

(defmethod monster-attack ((m hydra))
  (let ((x (randval (ash (monster-health m) -1))))
    (princ "A hydra attacks you with ")
    (princ x)
    (princ " of its heads!  It also grows back one more head! ")
    (incf (monster-health m))
    (decf *player-health* x)))
#+end_src

***** The Slimy Slime Mold

"The slime mold is a unique monster.  When it attacks you, it will wrap itself
around your legs and immobilize you, letting the other bad guys finish you off.
It can also squirt goo in your face.  You must think quickly in battle to
decide if it's better to finish the slime off early in order to maintain your
agility, or ignore it to focus on more vicious foes first."

#+begin_src lisp
(defstruct (slime-mold (:include monster)) (sliminess (randval 5)))
(push #'make-slime-mold *monster-builders*)

(defmethod monster-show ((m slime-mold))
  (princ "A slime mold with a sliminess of ")
  (princ (slime-mold-sliminess m)))

(defmethod monster-attack ((m slime-mold))
  (let ((x (randval (slime-mold-sliminess m))))
    (princ "A slime mold wraps around your legs and decreases your agility by ")
    (princ x)
    (princ "!  ")
    (decf *player-agility* x)
    (when (zerop (random 2))
      (princ "It also squirts in your face, taking away a health point!")
      (decf *player-health*))))
#+end_src

***** The Cunning Brigand

"The brigand is the smartest of all your foes.  He can use his whip or slingshot
and will try to neutralize your best assets.  His attacks are not powerful, but
they are a consistent two points for every round."

Brigand uses the generic monster =monster-show=.

#+begin_src lisp
(defstruct (brigand (:include monster)))
(push #'make-brigand *monster-builders*)

(defmethod monster-attack ((m brigand))
  (let ((x (max *player-health* *player-agility* *player-strength*)))
    (cond ((= x *player-health*)
           (princ "A brigand hits you with his slingshot, taking off 2 health points!  ")
           (decf *player-health* 2))
          ((= x *player-agility*)
           (princ "A brigand catches your leg with his whip, taking off 2 agility points!  ")
           (decf *player-agility* 2))
          ((= x *player-strength* 2)
           (princ "A brigand cuts your arm with his whip, taking off 2 strength points!  ")
           (decf *player-strength* 2)))))
#+end_src

* III - Lisp is Hacking
** Looping with the =loop= Command
*** The =loop= Macro

Within =loop=, =for= allows you to declare a variable that iterates through
a range of values.  By default, it will count through the integers starting
at zero.  =below= tells the =for= construct to halt when it reaches a value,
excluding the value itself.  =sum= adds together all values of a given
expression and makes the loop return that number.

#+begin_src lisp
(loop for i
      below 5
      sum i)
;; -> 10
#+end_src

*** Some =loop= Tricks
**** Counting from a Starting Point to an Ending Point

#+begin_src lisp
(loop for i
      from 5
      to 10
   sum i)
;; -> 45
#+end_src

**** Iterating Through Values in a List

#+begin_src lisp
(loop for i
      in '(100 20 3)
    sum i)
;; -> 123
#+end_src

**** doing Stuff in a Loop

#+begin_src lisp
(loop for i
      below 5
    do (print i))
;; -> prints ut 0 1 2 3 4, each on its own line
#+end_src

**** Doing Stuff Under Certain Conditions

#+begin_src lisp
(loop for i
      below 10
    when (oddp i)
    sum i)
;; -> 25
#+end_src

**** Breaking out of a Loop Early

#+begin_src lisp
(loop for i
      from 0
   do (print i)
   when (= i 5)
   return 'falafel)
;; -> prints 0 to 5 on separate lines, then it returns the value 'falafel
#+end_src

**** Collecting a List of Values

The =collect= clause lets you return more than one item from the =loop=, in
the form of a list.

#+begin_src lisp
(loop for i
   in '(2 3 4 5 6)
   collect (* i i))
;; -> (4 9 16 25 36)
#+end_src

**** Using Multiple =for= Clauses

The below iterates x and y at the same time, and returns a list of 10 numbers.
The loop will stop when either =for= clause runs out of values.

#+begin_src lisp
(loop for x below 10
      for y below 10
      collect (+ x y))
;; -> (0 2 4 6 8 10 12 14 16 18)
#+end_src

If we wanted to generate the cartesian product, we would need nested loops.

#+begin_src lisp
(loop for x below 10
      collect (loop for y below 10
                    collect (+ x y)))
;; -> lots of output.  0 to 9, then 1 to 10, then 2 to 11, etc
;;    this returns 10 lists of 10 items each, 100 items total
#+end_src

Double =for= clauses is an easy way to pair up values with an index.

#+begin_src lisp
(loop for i
      from 0
      for day
      in '(monday tuesday wednesday thursday friday saturday sunday)
      collect (cons i day))
;; -> ((0 . MONDAY) (1 . TUESDAY) (2 . WEDNESDAY) ...)
#+end_src

**** There's ALOT of other =loop= tricks.  The book has a huge table.
*** Using =loop= to Evolve!
**** Intro to the Game

Our game world is a simple rectangular plane, with edges that wrap around to
the opposite side.  Most of this world is covered in steppes, meaning that very
few plants grow for the animals to eat.  In the center of the world is a small
jungle, where plants grow much faster.  Our animals, who are herbivores, will
forage this world in search of food.

**** Full Code in evolution.lisp
**** Example of =loop=

Here's two functions that use loop from evolution.lisp.  I didn't find this one
instructive enough to break it all up in a org-file like I did Wumpus and Orc
Battle.

#+begin_src lisp
(defun draw-world ()
  (loop for y
          below *height*
        do (progn (fresh-line)
                  (princ "|")
                  (loop for x
                          below *width*
                        do (princ (cond ((some (lambda (animal)
                                                 (and (= (animal-x animal) x)
                                                      (= (animal-y animal) y)))
                                               *animals*)
                                         #\M)
                                        ((gethash (cons x y) *plants*) #\*)
                                        (t #\space))))
                  (princ "|"))))

(defun evolution ()
  (draw-world)
  (fresh-line)
  (let ((str (read-line)))
    (cond ((equal str "quit") ())
          (t (let ((x (parse-integer str :junk-allowed t)))
               (if x
                   (loop for i
                           below x
                         do (update-world)
                         if (zerop (mod i 100))
                           do (princ #\.))
                   (draw-world))
               (evolution))))))
#+end_src

** Printing Text with the =format= Function
*** Anatomy of the =format= Function

#+begin_src lisp
(format t "Add onion rings for only ~$ dollars more!" 1.5)
;; OUTPUT: Add onion rings for only 1.50 dollars more!
;; -> NIL
#+end_src

The first parameter is "The Destination Parameter".  It is =nil= to just create
a string, =t= for printing to console, and =stream= to output to stream.
Everything between quotes is "The Control String," and =~$= is a Control
Sequence.  The 1.5 is a Value Parameter.

***** The Destination Parameter
****** =nil= to return value as a string
****** =t= to print value to the console (and return =nil=)
****** =stream= to write data to an output stream (covered next chapter)
***** The Control String Parameter
****** By default, the text in this string is printed as output
****** /control sequences/ in the string affect the output
******* All control sequences begin with ~
******* Use =~s= and =~a= to print like =prin1= and =princ=

Print any lisp value.  With =~s= it will show appropriate delimiters.  With
=~a= it will show the value without delimiters.  We can adjust this further
by putting a number n in front of the a or s to indicate the value should be
padded with blank spaces on the right.  This will add spaces until the total
width of the value is n.  =~10a= with "foo" will add seven spaces.  We can add
spaces on the left by adding =@= like =~10@a= with "foo" will put seven spaces
in front of foo.  Control sequences can take multiple parameters separated by
,.  Like =~10,3a= with "foo" will cause the spaces to be added 3 at a time until
10 is reached, so in this example, 9 spaces are added (the total width is 12).
The second parameter to =~a= is rarely used.  The third parameter makes us
print an exact number of spaces after a final formatted value, like =~,,4a= to
print exactly 4 spaces after the data.  The fourth parameter chooses another
character to pad with rather than space.  =~,,,4,'!@a= and "foo" will print
"foo!!!!"

#+begin_src lisp
(format t "I am printing ~s in the middle of this sentence." "foo")
;; I am printing "foo" in the middle of this sentence.
(format t "I am printing ~a in the middle of this sentence." "foo")
;; I am printing foo in the middle of this setence.
(format t "I am printing ~10a within ten spaces of room." "foo")
;; I am printing foo       within ten spaces of room.
#+end_src

******* Control Sequences for Formatting Numbers
******** =~x= to display a number in hexadecimal.  =~b= for binary.
******** =~d= is decimal, but can be combined with parameters

=~:d= display a number with commas.  We can also use padding with =~d=, like
=~10d= to make it a 10 space width number field.  With =~d= the padding
character is the second parameter so =~10,'xd= with 1000000 is xxx1000000.

******** =~f= is floating point and can be combined with parameters

=~4f= displays a floating point that is four characters wide, so =~4f= with
3.141593 will print "3.14" (the decimal is one of the four characters).  The
second parameter to =~f= controls how many digits after the decimal point,
so =~,4f= with 3.141593 will print "3.1416" (it rounds the number off).  The
third parameter causes the value to be scaled by factors of 10.  So
=~,,2f= and 0.77 will display "77.0"

******** =~$= - monetary floating-point value
******* You can print in columns with =~t= and =~:@= and =~<=
******* =format= can iterate through lists with =~{= and =~}=

#+begin_src lisp
(format t "~{I see a ~a! ~}" *animals*)
;; will print out "I see a whatever!" once for each animal in *animals*
#+end_src

***** Value Parameters
****** Parameters following the control string contain data to be displayed
*** Printing Multiple Lines of Output
**** =terpri= will start a new line
**** =fresh-line= will start a new line as long as there isn't already a new line
**** =format= has two sequences for new lines
***** =~%= is like =terpri=
***** =~&= is like =fresh-line=
***** Both take a parameter for number of lines, so =~5&= does 5 new lines
*** Attack of the Robots Game
**** Intro to the Game

In this game, robots have taken over the world, and it's your job to destroy
them.  To win the game, you need to strategically walk around the field to
cause all robots to collide with each other.  The movement keys are:
QWE/ASD/ZXC.  These characters form a grid on the left side of your keyboard,
letting you move up, down, left, right, as well as diagonally.  You can
also teleport with the T key.

It's a pretty cool game.  A little easy.  But it would be impossible if you
couldn't teleport.  Anyway, it shows abuse of the =loop= and =format= functions
in about a page of code.

**** Full Code in robots.lisp
**** Full Code Also Here

#+begin_src lisp
(defun robots ()
  (loop named main
        with directions = '((q . -65) (w . -64) (e . -63) (a . -1)
                            (d .   1) (z .  63) (x .  64) (c . 65))
        for pos = 544
        then (progn (format t "~%qwe/asd/zxc to move, (t)eleport, (l)eave:")
                    (force-output)
                    (let* ((c (read))
                           (d (assoc c directions)))
                      (cond (d (+ pos (cdr d)))
                            ((eq 't c) (random 1024))
                            ((eq 'l c) (return-from main 'bye))
                            (t pos))))
        for monsters = (loop repeat 10
		             collect (random 1024))
        then (loop for mpos in monsters
                   collect (if (> (count mpos monsters) 1)
			         mpos
                               (cdar (sort (loop for (k . d) in directions
					            for new-mpos = (+ mpos d)
                                                 collect (cons (+ (abs (- (mod new-mpos 64)
                                                                          (mod pos 64)))
                                                                  (abs (- (ash new-mpos -6)
                                                                          (ash pos -6))))
                                                               new-mpos))
                                           '<
                                           :key #'car))))
        when (loop for mpos in monsters
                   always (> (count mpos monsters) 1))
        return 'player-wins
        do (format t
                   "~%|~{~<|~%|~,65:;~A~>~}|"
                   (loop for p
                         below 1024
                         collect (cond ((member p monsters)
                                        (cond ((= p pos) (return-from main 'player-loses))
                                              ((> (count p monsters) 1) #\#)
                                              (t #\A)))
                                       ((= p pos)
                                        #\@)
                                       (t
                                        #\ ))))))
#+end_src

** Working with Streams
*** Streams by Type of Resource
**** Console Streams
**** File Streams
**** Socket Streams
**** String Streams

Rather than let you communicate with the outside world, string streams allow
you to manipulate strings in new and interesting ways.

*** Streams by Direction
**** Output Streams

You can do two things with an output stream:
- Check whether the stream is valid.
- Push a new item onto the stream.

#+begin_src lisp
;; output-stream-p tells us if a stream is valid
(output-stream-p *standard-output*)
;; -> T
(write-char #\x *standard-output*)
;; -> xNIL
#+end_src

**** Input Streams

You can do two things with an input stream:
- Check whether the stream is valid
- Pop an item off of the stream

#+begin_src lisp
;; input-stream-p tests if a stream is valid
(input-stream-p *standard-input*)
;; -> T
(read-char *standard-input*)
;; 123
;; -> #\1
#+end_src

*** Using Other Commands to Interact with Streams
**** =print= takes an extra param: =(print 'foo *standard-output*)=
**** lots of other commands also take a stream as a parameter
*** Working with Files
**** =with-open-file= should be your go to way to work with files

#+begin_src lisp
;; print "my data" to a file named data.txt
(with-open-file (my-stream "data.txt" :direction :output)
  (print "my data" my-stream))
(with-open-file (my-stream "data.txt" :direction :input)
  (read my-stream))
;; -> "my data"
#+end_src

*** Working with Sockets
**** Sending a Message over a Socket

Get two clisp's up and running in different console windows.  One will be the
server and the other the client.  The server is the one that listens.
Note: this code is clisp specific
The following opens a bidirectional stream between two consoles.

#+begin_src lisp
;; from the server do the following
(defparameter my-socket (socket-server 4321))
(defparameter my-stream (socket-accept my-socket))
;; now from the client console
(defparameter my-stream (socket-connect 4321 "127.0.0.1"))
;; now use the stream from either
;; from the client
(print "Yo Server!" my-stream)
;; from the server
(read my-stream)
;; -> "Yo Server!"
(print "What up, Client!" my-stream)
;; back on the client
(read my-stream)
;; -> "What up, Client!"
;; now on both the client and server, run the following:
(close my-stream)
;; then on the server, run this to free up the port:
(socket-server-close my-socket)
#+end_src

*** String Streams
**** =make-string-input-stream= makes a string input stream
**** =make-string-output-stream= makes a string output stream

#+begin_src lisp
(defparameter foo (make-string-output-stream))
(princ "This will go into foo.  " foo)
(princ "This will also go into foo.  " foo)
(get-output-stream-string foo)
;; -> "This will go into foo.  This will also go into foo.  "
#+end_src

**** String Streams are useful for debugging and creating complex strings
**** =with-output-to-string=) macro is great for debugging

#+begin_src lisp
(with-output-to-string (*standard-output*)
  (princ "the sum of ")
  (princ 5)
  (princ " and ")
  (princ 2)
  (princ " is ")
  (princ (+ 2 5)))
;; -> "the sum of 5 and 2 is 7"
#+end_src

** Let's Create a Web Server!
*** Error Handling in Common Lisp
**** Signal a Condition with =error= like =(error "foo")=
**** Create Custom Conditions with =define-condition=

Yes, starting with two () ()'s is on purpose.

#+begin_src lisp
(define-condition foo () ()
  (:report (lambda (condition stream)
             (princ "Stop FOOing around, numbskull!" stream))))
;; now we can signal our custom condition with =error=
(error 'foo)
#+end_src)

**** Intercept Conditions with =handler-case=

#+begin_src lisp
(define-condition foo () ()
  (:report (lambda (condition stream)
             (princ "Stop FOOing aroun, numbskull!" stream))))

(defun bad-function ()
  (error 'foo))

(handler-case (bad-function)
  (foo () "somebody signaled foo!")
  (bar () "somebody signaled bar!"))
;; -> "somebody signaled foo!"
#+end_src)))

**** Use =unwind-protect= to always run a piece of code

You can usually use a with- macro and avoid calling =unwind-protect= directly.

#+begin_src lisp
;; the message needs to be printed, even after the divide by zero
(unwind-protect (/ 1 0)
                (princ "I need to say 'flubyduby' no matter what"))
#+end_src

*** Writing a Web Server from Scratch
**** Decoding the Values of Request Parameters

The follow code decodes params (like foo%3F to foo)?) and turns them
into alist from a string of params like "name=bob&age=25&gender=male"

#+begin_src lisp
;; this takes the two characters after the % in an http encoded string
;; (the two hex digits) and converts it to a char.  for invalid codes,
;; it returns #\Space by default, but that is a parameter
;; for (http-char #\3 #\F) it would return "?"
(defun http-char (c1 c2 &optional (default #\Space))
  (let ((code (parse-integer
               (coerce (list c1 c2) 'string)
               :radix 16
               :junk-allowed t)))
    (if code
        (code-char code)
        default)))

;; this decodes a param, for example given "foo" it returns "foo"
;; for "foo%3F" it returns "foo?", and "foo+bar" is "foo bar"
(defun decode-param (s)
  (labels ((f (lst)
             (when lst
               (case (car lst)
                 (#\% (cons (http-char (cadr lst) (caddr lst))
                            (f (cdddr lst))))
                 (#\+ (cons #\space (f (cdr lst))))
                 (otherwise (cons (car lst) (f (cdr lst))))))))
    (coerce (f (coerce s 'list)) 'string)))

;; this parses params in the form "name=bob&age=25&gender=male"
;; returns an alist: ((NAME . "bob") (AGE . "25") (GENDER . "male"))
(defun parse-params (s)
  (let* ((i1 (position #\= s))
         (i2 (position #\& s)))
    (cond (i1 (cons (cons (intern (string-upcase (subseq s 0 i1)))
                          (decode-param (subseq s(1+ i1) i2)))
                    (and i2 (parse-params (subseq s (1+ i2))))))
          ((equal s "") nil)
          (t s))))
#+end_src

**** Parsing the Request Header

The first line of the request header looks like
"GET /lolcats.html HTTP/1.1" or with params
"GET /lolcats.html?extra-funny=yes HTTP/1.1".  We're skipping the method
(GET or POST, etc), which a fancier web server would handle.
The rest of the header looks like:
"Host: www.mywebsite.com
 User-Agent: Mozilla/5.0
 Header: Value, etc"

#+begin_src lisp
;; this parses an http request header, for example:
;; "GET /lolcats.html HTTP/1.1" would return ("lolcats.html")
;; it also parses URL params, so:
;; "GET /lolcats.html?extra-funny=yes HTTP/1.1" would return
;; ("lolcats.html" (EXTRA-FUNNY . "yes"))
(defun parse-url (s)
  (let* ((url (subseq s
                      (+ 2 (position #\space s))
                      (position #\space s :from-end t)))
         (x (position #\? url)))
    (if x
        (cons (subseq url 0 x) (parse-params (subseq url (1+ x))))
        (cons url '()))))

;; parse-url handles the first list.  get-header processes the rest of the
;; request header and returns an alist
(defun get-header (stream)
  (let* ((s (read-line stream))
         (h (let ((i (position #\: s)))
              (when i
                (cons (intern (string-upcase (subseq s 0 i)))
                      (subseq s (+ i 2)))))))
    (when h
      (cons h (get-header stream)))))
#+end_src

**** Testing =get-header= with a String Stream

We can test get-header with a string stream instead of waiting until we can
supply it with a socket stream.  To do so, you can use
=make-string-input-stream= to create a string stream.  This allows you to
make a multi-line input-stream by hitting enter before closing your quotes.

#+begin_src lisp
[80]> (get-header (make-string-input-stream "  foo: 1
bar: abc, 123
"))
;; -> ((|  FOO| . "1") (BAR . "abc, 123"))
#+end_src

**** Parsing the Request Body

In a POST request, there are parameters store beneath the header, in an
area known as the /request body/ or /request content/.  We can extract
these will the following function:

#+begin_src lisp
;; this will parse a request body contained in a POST request
;; it's stored like URL params, so we can re-use parse-params
(defun get-content-params (stream header)
  (let ((length (cdr (assoc 'content-length header))))
    (when length
      (let ((content (make-string (parse-integer length))))
        (read-sequence content stream)
        (parse-params content)))))
#+end_src

**** The =serve= Function

#+begin_src lisp
;; Now for the heart of our web server!
(defun serve (request-handler)
  (let ((socket (socket-server 8080)))
    (unwind-protect
         (loop (with-open-stream (stream (socket-accept socket))
                 (let* ((url    (parse-url (read-line stream)))
                        (path   (car url))
                        (header (get-header stream))
                        (params (append (cdr url)
                                        (get-content-params stream header)))
                        (*standard-output* stream))
                   (funcall request-handler path header params))))
      (socket-server-close socket))))
#+end_src

**** A simple request handler

#+begin_src lisp
;; We're going to define a simple request handler to provide our serve function
(defun hello-request-handler (path header params)
  (if (equal path "greeting")
      (let ((name (assoc 'name params)))
        (if (not name)
            (princ "<html><form>What is your name?<input name='name' /></form></html>")
            (format t "<html>Nice to meet you, ~a!</html>" (cdr name))))
      (princ "Sorry...  I don't know that page.")))
#+end_src

Because of the way we designed it, the request handler is really easy to debug
without even starting up the server.  Below is a session seeing how it works:

#+begin_src lisp
[82]> (load "web-server")
;; Loading file /Users/Lewis/git/books/land-of-lisp/web-server.lisp ...
;; Loaded file /Users/Lewis/git/books/land-of-lisp/web-server.lisp
T
[83]> (hello-request-handler "lolcats" '() '())
Sorry...  I don't know that page.
"Sorry...  I don't know that page."
[84]> (hello-request-handler "greeting" '() '())
<html><form>What is your name?<input name='name' /></form></html>
"<html><form>What is your name?<input name='name' /></form></html>"
[85]> (hello-request-handler "greeting" '() '((name . "Bob")))
<html>Nice to meet you, Bob!</html>
NIL
#+end_src

**** Launching the Website

To test, we just need to load the web-server.lisp file in clisp and call
=(serve #'hello-request-handler)= (remember, you need to start a reference
to a function with #').  Then we can view our site at
http://localhost:8080/greeting

* IV - Lisp is Science
** Ramping Lisp Up a Notch with Functional Programming
*** The Central Philosophy of Functional Programming

You should break your program into two parts:

- The first, and biggest part, should be completely functional and free of side
effects.  This is the clean part of your program.
- The second, smaller part of your program is the part that has all the side
effects, interacting with the user and the rest of the outside world.  This
code is dirty and should be kept as small as possible.

** Dice of Doom, a Game Written in the Functional Style
*** The Rules of Dice of Doom

"Here's the simplified rules we'll start with:

- Two players (named A and B) occupy spaces on a hexagonal grid.  Each hexagon
in the grid will have some six-sided dice on it, owned by the occupant.
- During a turn, a player can perform any number of moves, but must perform
at least one move.  If the player cannot move, the game ends.
- A move consists of attacking a neighboring hexagon owned by the opponent.
The player must have more dice in her hexagon than the neighboring hexagon in
order to attack.  For now, all attacks will automatically lead to a win.  In
future variants, we'll actually roll the dice for a battle.  But for now, the
player with more dice just wins automatically.
- After winning a battle, the losing player's dice are removed from the board,
and all but one of the winning player's dice are moved onto the newly won
hexagon.
- After a player is finished making her moves, reinforcements are added to that
player's dice armies.  Reinforcements to the player's occupied hexagons are
added one die at a time, starting from the upper-left corner, moving across and
down.  The maximum number of dice added as reinforcements is one less than the
player took from the opponent in her completed turn.
- When a player can no longer take her turn, the game has ended.  The player
who occupies the most hexagons at this point is the winner.  (A tie is also
possible.)"

*** Full Code in dice-of-doom-v1.lisp

I'm not going to embed all the code for dice of doom in this org-file.  A
commented version exists on my git repo at
https://github.com/llcawthorne/land-of-lisp/dice-of-doom-v1.lisp

*** Memoization

Since a pure function only calculates a result given its arguments, we can
/memoize/ it as an optimization.  We basically remember the arguments and
result of each call of the function.  It trades memory for performance.

#+begin_src lisp
;; This is what we'll be memoizing
;; clean functional code to calculate the neighboring hexagons to a given hex
;; a hexagon may have up to 6 neighbors (fewer if on edge of board)
(defun neighbors (pos)
  (let ((up (- pos *board-size*))
        (down (+ pos *board-size*)))
    (loop for p in (append (list up down)
                           (unless (zerop (mod pos *board-size*))
                             (list (1- up) (1- pos)))
                           (unless (zerop (mod (1+ pos) *board-size*))
                             (list (1+ pos) (1+ down))))
          when (and (>= p 0) (< p *board-hexnum*))
            collect p)))

;; here's where we memoize it; using a hash table to store results
(let ((old-neighbors (symbol-function 'neighbors))
      (previous (make-hash-table)))
  (defun neighbors (pos)
    (or (gethash pos previous)
        (setf (gethash pos previous) (funcall old-neighbors pos)))))
#+end_src

*** Tail Call Optimization
**** Not Tail Recursive

#+begin_src lisp
(defun my-length (lst)
  (if lst
    (1+ (my-length (cdr lst)))
    0))
#+end_src

**** Tail Recursive

#+begin_src lisp
(defun my-length (lst)
  (labels ((f (lst acc)
              (if lst
                (f (cdr lst) (1+ acc))
                acc)))
    (f lst 0)))

;; required for tail call optimization in clisp
(compile 'my-length)
#+end_src

** The Magic of Lisp Macros
*** A Simple Lisp Macro

Imagine how many parentheses =let= uses.  It's kinda silly for a single var
instead of a group of declarations.  Let's fix that.

#+begin_src lisp
;; original let
(let ((foo (+ 2 3)))
  (* foo foo)

;; define our macro
(defmacro let1 (var val &body body)
 `(let ((,var ,val))
    ,@body))

;; now use our let1
(let1 foo (+ 2 3)
  (* foo foo))
#+end_src

*** Macro Expansion

/macro expansion/ happens to your code before the core of the Lisp
interpreter/compiler gets to see it.  The macro expander finds any macros
in your code and converts them into regular Lisp code.  Macros are run at a
different time than a function is run.  Functions run during execution, at
/runtime/.  A macro runs before the program does, at /macro expansion time/.

*** How Macros Are Transformed

Recall our simple =let1= macro.

#+begin_src lisp
;; this is what it looks like when we define let1
(defmacro let1 (var val &body body)
  `(let ((,var ,val))
     ,@body))

;; this is what it looks like when we use let1
(let1 foo (+ 2 3)
  (* foo foo))
#+end_src

The =defmacro= call tells the macro expander that when you see =let1= you need
to expand it.  It all has the arguments passed into it.  =let1= has three
arguments: =var=, =val=, and =body=.   When we use the macro, =foo= is the
=var=, =(+ 2 3)= is the =val=, and =((* foo foo))= is the =body=.  The =body=
is a nested list, because it is accessed as a varargs parameter which is a list
of all the remaining arguments.  We only put =(* foo foo)= when we used it, but
when we access it we get a list of one element: =((* foo foo))=

We use quasiquoting to define what the =let1= macro translates to in Lisp code.
In our =let1= macro, the body is =`(let ((,var ,val)) ,@body))=.  The commas
cause the values of =var= and =val= to be inserted at those locations.  The
=body= argument is inserted using the splicing comma (,@).  It let's us insert
the entire list of forms for the =body=.

You can use the =macroexpand= command to see code generated by a macro.  Note
how you have to quote the code you pass to =macroexpand=.  For example:

#+begin_src lisp
(macroexpand '(let1 foo (+ 2 3)
                 (* foo foo)))
;; -> (LET ((FOO (+ 2 3))) (* FOO FOO)) ;
;;    T
#+end_src

*** More Complex Macros

#+begin_src lisp
;; consider this tail recursive length function
(defun my-length (lst)
  (labels ((f (lst acc)
            (if lst
              (f (cdr lst) (1+ acc))
              acc)))
     (f lst 0)))

;; this handles checking the list is non-null and splitting it into head and tail
;; this version contains a bug
(defmacro split (val yes no)
  `(if ,val
    (let ((head (car ,val))
          (tail (cdr ,val)))
       ,yes)
       ,no))

;; improved my-length
(defun my-length (lst)
  (labels ((f (lst acc)
            (split lst
              (f tail (1+ acc))
              acc)))
    (f lst 0)))
#+end_src

**** Avoiding Repeated Execution in Macros

Our split macro evaluates =val= three times.  This could cause side effects to
fire multiple times (like if =val= was a =progn= statement with =princ= and a
list at the end.  We can fix that with a =let= or even =let1= statement.

#+begin_src lisp
;; Warning!  Still contains a bug!
(defmacro split (val yes no)
  `(let1 x ,val
    (if x
       (let ((head (car x))
             (tail (cdr x)))
         ,yes)
         ,no)))
#+end_src

**** Avoiding Variable Capture

Our new =split= macro has another bug.  It captured the variable name =x=, so
if we use it somewhere there is already a variable named =x=, it will shadow it.
There is a Common Lisp function named =gensym= that generates a crazy variable
name for you, so you're not likely to have collisions.

#+begin_src lisp
;; This version of split is safe to use
(defmacro split (val yes no)
  (let1 g (gensym)
    `(let1 ,g ,val
       (if ,g
         (let ((head (car ,g))
               (tail (cdr ,g)))
           ,yes)
           ,no))))
#+end_src

Note that our backquote doesn't start above until the second let1 statement.
The first statement of setting =g= to =gensym= is run at macro expand time,
not runtime.

**** A Recursion Macro

=my-length= could also use some cleanup of defining it's recursive =f= function
to be tail recursive.  We're going to create a =recurse= macro to help with that.

#+begin_src lisp
;; to write this macro, we need to process a list of arguments and starting
;; values, so we'll define a =pairs= function to help us out
(defun pairs (lst)
  (labels ((f (lst acc)
            (split lst
              (if tail
                (f (cdr tail) (cons (cons head (car tail)) acc))
                (reverse acc))
              (reverse acc))))
    (f lst nil)))
(pairs '(a b c d e f))
;; -> ((A . B) (C . D) (E . F))

;; now for our recurse macro
(defmacro recurse (vars &body body)
  (let1 p (pairs vars)
    `(labels ((self ,(mapcar #'car p)
                ,@body))
       (self ,@(mapcar #'cdr p)))))

;; now let's cleanup =my-length=
(defun my-length (lst)
  (recurse (lst lst
            acc 0)
           (split lst
             (self tail (1+ acc))
             acc)))
#+end_src

*** Macros: Dangers and Alternatives

The main drawback of macros is that they can make it hard for other programmers
to understand your code.  Also, sometimes functional programming provides a
better, more understandable, and more composable solution.  Consider cleaning
up the recursion in =my-length= instead by using reduce.

#+begin_src lisp
(defun my-length (lst)
  (reduce (lambda (x i)
            (1+ x))
          lst
          :initial-value 0))
#+end_src

** Domain-Specific Languages
*** Writing SVG Files
**** Example SVG File

#+begin_src xml
<svg xmlns="http://www.w3.org/2000/svg">
  <circle cx="50"
          cy="50"
          r="50"
          style="fill:rgb(255,0,0);stroke:rgb(155,0,0)">
  </circle>
  <circle cx="100"
          cy="100"
          r="50"
          style="fill:rgb(0,0,255);stroke:rgb(0,0,155)">
  </circle>
</svg>
#+end_src

**** Writing a Macro Helper Function

Often, when writing a macro to perform a task, you'll find a lot of what
your macro needs to do can be handled by a function instead.  Because of this
it is often prudent to first write a helper function.  Here we will write one
that prints a single opening or closing tag.

#+begin_src lisp
;; prints a single opening or closing tag
(defun print-tag (name alst closingp)
  (princ #\<)
  (when closingp
    (princ #\/))
  (princ (string-downcase name))
  (mapc (lambda (att)
          (format t " ~a=\"~a\"" (string-downcase (car att)) (cdr att)))
        alst)
  (princ #\>))

(print-tag "circle" '() t)
;; </circle>
(print-tag 'mytag '((color . blue) (height . 9)) nil)
;; <mytag color="BLUE" height="9">
#+end_src

**** Creating the =tag= Macro

=tag= macro improves on the =print-tag= function in several ways:
- Tags always come in pairs, and we need to be able to nest tags
  within other tags.  With a macro, we can execute code before and after
  nested tags are evaluated.
- Tag names and attribute names usually do not need to change in
  a dynamic way.  Because of this, it's redundant to need to prefix tag
  names with a single quote.  Tag names should be default be treated
  as if they were in data mode.
- Unlike tag names, it's desirable for the values of attributes to be
  dynamically generated.  Our macro will have a syntax that places
  the attribute values into code mode so we can execute Lisp code
  to populate these values.

#+begin_src lisp
;; ideally, this is how our macro should work
(tag mytag (color 'blue height (+ 4 5)))
;; <mytag color="BLUE" height="9"></mytag>

(defmacro tag (name atts &body body)
  `(progn (print-tag ',name
                     (list ,@(mapcar (lambda (x)
                                       `(cons ',(car x) ,(cdr x)))
                                     (pairs atts)))
                     nil)
          ,@body
          (print-tag ',name nil t)))

(tag mytag (color 'blue size 'big)
  (tag first_inner_tag ())
  (tag second_inner_tag ()))
;; <mytag color="BLUE" size="BIG">
;;   <first_inner_tag></first_inner_tag>
;;   <second_inner_tag></second_inner_tag>
;; </mytag>
#+end_src))

**** Using the =tag= Macro to Generate HTML

#+begin_src lisp
(tag html ()
  (tag body ()
    (princ "Hello World!")))
;; <html><body>Hello World!</body></html>

;; We could define special macros to make HTML even easier
(defmacro html (&body body)
  `(tag html ()
     ,@body))
(defmacro body (&body body)
  `(tag body ()
     ,@body))

(html
  (body
    (princ "Hello World!")))
;; <html><body>Hello World!</body></html>
#+end_src)))

**** Creating SVG-Specific Macros and Functions

The first attribute =svg= assigns is just the source of the documentation
for the SVG format, but the second allows us to embed links in SVG's.
Then we need some helpers for colors, svg-style, and to draw circles.

#+begin_src lisp
(defmacro svg (&body body)
  `(tag svg (xmlns "http://www.w3.org/2000/svg"
             "xmlns:xlink" "http://www.w3.org/1999/xlink")
        ,@body))

;; We're storing colors as lists of RGB values: (255 0 0)
;; this adds to all a colors RGB values to make it brighter or darker
(defun brightness (col amt)
  (mapcar (lambda (x)
            (min 255 (max 0 (+ x amt))))
          col))

;; svg-style sets the style of an SVG picture element
;; it sets the outline color to a darker variant of the fill color
(defun svg-style (color)
  (format nil
          "~{fill:rgb(~a,~a,~a);stroke:rgb(~a,~a,~a)~}"
          (append color
                  (brightness color -100))))

;; since we don't need to nest other tags within a circle, we can use a function
(defun circle (center radius color)
  (tag circle (cx (car center)
                  cy (cdr center)
                  r radius
                  style (svg-style color))))

;; Now we can draw our sample image from above
(svg (circle '(50 . 50) 50 '(255 0 0))
     (circle '(100 . 100) 50 '(0 0 255)))
;; <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><circle cx="50" cy="50" r="50" style="fill:rgb(255,0,0);stroke:rgb(155,0,0)"></circle><circle cx="100" cy="100" r="50" style="fill:rgb(0,0,255);stroke:rgb(0,0,155)"></circle></svg>
#+end_src

**** Building a More Complicated SVG Example

#+begin_src lisp
;; svg also support polygons
;; the poly con takes points like ((0 . 200) (10 . 100))
;; and a color like red: (255 0 0)
(defun polygon (points color)
  (tag polygon (points (format nil
                               "~{~a,~a ~}"
                               (mapcan (lambda (tp)
                                         (list (car tp) (cdr tp)))
                                       points))
                       style (svg-style color))))

;; and this will generate a random walk from a value and length
;; Example: (random-walk 100 10)
;; Returns: (100 101 102 101 100 101 102 103 102 103)
(defun random-walk (value length)
  (unless (zerop length)
    (cons value
          (random-walk (if (zerop (random 2))
                           (1- value)
                           (1+ value))
                       (1- length)))))

;; now let's draw a slew of random walks to random_walk.svg
(with-open-file (*standard-output* "random_walk.svg"
                                   :direction :output
                                   :if-exists :supersede)
  (svg (loop repeat 10
             do (polygon (append '((0 . 200))
                                 (loop for x
                                       for y in (random-walk 100 400)
                                       collect (cons x y))
                                 '((400 . 200)))
                         (loop repeat 3
                               collect (random 256))))))
#+end_src

*** Creating Custom Game Commands for Wizard's Adventure Game
**** Creating New Commands by Hand

To decide what your DSL should look like, you need to first create
some commands by hand.  Then we can see if there are any common patterns
between different commands that we can use as the basis for our DSL.

***** Weld Command

First, we want a way to let the player weld the chain and the bucket if
they bring them to the welding machine in the attic.

#+begin_src lisp
(defun have (object)
  (member object (inventory)))

(defparameter *chain-welded* nil)

(defun weld (subject object)
  (if (and (eq *location* 'attic)
           (eq subject 'chain)
           (eq object 'bucket)
           (have 'chain)
           (have 'bucket)
           (not *chain-welded*))
      (progn (setf *chain-welded* t)
             '(the chain is now securely welded to the bucket.))
      '(you cannot weld like that.)))

;; we need to add weld to our allowed game-repl commands
(pushnew 'weld *allowed-commands*)
#+end_src

***** Dunk Command

We also want to add a new command to let the player dunk the welded bucket
in the garden well.

#+begin_src lisp
(defparameter *bucket-filled* nil)

(defun dunk (subject object)
  (if (and (eq *location* 'garden)
           (eq subject 'bucket)
           (eq object 'well)
           (have 'bucket)
           *chain-welded*)
      (progn (setf *bucket-filled* 't)
             '(the bucket is now full of water))
      '(you cannot dunk like that.)))

(pushnew 'dunk *allowed-commands*)
#+end_src

**** =game-action= Macro

Dunk and Weld were very similar.  Let's define a macro that let's us define
new commands like them.

#+begin_src lisp
(defmacro game-action (command subj obj place &body body)
  `(progn (defun ,command (subject object)
            (if (and (eq *location* ',place)
                     (eq subject ',subj)
                     (eq object ',obj)
                     (have ',subj))
                ,@body
                '(i cannot ,command like that.)))
          (pushnew ',command *allowed-commands*)))
#+end_src

**** Defining our commands with =game-action= macro

#+begin_src lisp
;; now we'll define weld and dunk with our new macro
(defparameter *chain-welded* nil)

(game-action weld chain bucket attic
             (if (and (have 'bucket) (not *chain-welded*))
                 (progn (setf *chain-welded* 't)
                        '(the chain is now securely welded to the bucket.))
                 '(you do not have a bucket.)))

(defparameter *bucket-filled* nil)

(game-action dunk bucket well garden
             (if *chain-welded*
                 (progn (setf *bucket-filled* 't)
                        '(the bucket is now full of water))
                 '(the water level is too low to reach.)))

;; and a new command to splash the wizard
(game-action splash bucket wizard living-room
             (cond ((not *bucket-filled*) '(the bucket has nothing in it.))
                   ((have 'frog) '(the wizard awakens and sees that you stole his frog.
                                   he is so upset he banishes you to the netherworlds - you lose!  the end.))
                   (t '(the wizard awakens from his slumber and greeets you warmly.
                        he hands you the magic low-carb donut - you win!  the end.))))
#+end_src

** Lazy Programming
*** Adding Lazy Evaluation to Lisp

The idea is that we don't want to generate the whole game tree up front.  We
want to generate branches only when they're needed.  Common Lisp doesn't have
any built in support for this type of lazy evaluation, so we're going to add
it through macros.

*** Lazy Library being stored in lazy.lisp and in org src blocks
**** Creating the =lazy= and =force= commands

We can use =lazy= to wrap a piece of code we want lazily evaluated.  We call
the code with =force= to force evaluation.

#+begin_src lisp
;; Here's an example of how these functions will work
(defun add (a b)
  (princ "I am adding now")
  (+ a b))
(defparameter *foo* (lazy (add 1 2)))
;; -> *FOO*
(force *foo*)
;; I am adding now
;; -> 3

;; Here's the code for lazy
(defmacro lazy (&body body)
  (let ((forced (gensym))
        (value (gensym)))
    `(let ((,forced nil)
           (,value nil))
       (lambda ()
         (unless ,forced
           (setf ,value (progn ,@body))
           (setf ,forced t))
         ,value))))

;; the force function is a lot simpler
(defun force (lazy-value)
  (funcall lazy-value))
#+end_src

**** Creating a Lazy Lists Library

#+begin_src lisp
;; now we can start a list library
(defmacro lazy-cons (a d)
  `(lazy (cons ,a ,d)))

(defun lazy-car (x)
  (car (force x)))

(defun lazy-cdr (x)
  (cdr (force x)))

;; now lets use our lazy library to define the integers
(defparameter *integers*
  (labels ((f (n)
             (lazy-cons n (f (1+ n)))))
    (f 1)))
;; (lazy-cdr *integers*) returns a function.  if you funcall it, you get
;; (2 . #<FUNCTION)

;; not all lazy lists are infinite, so we need lazy-nil
(defun lazy-nil ()
  (lazy nil))

(defun lazy-null (x)
  (not (force x)))
#+end_src

**** Converting Between Regular Lists and Lazy Lists

#+begin_src lisp
;; now we need a way to convert a regular list to a lazy list
(defun make-lazy (lst)
  (lazy (when lst
          (cons (car lst) (make-lazy (cdr lst))))))

;; (take 10 *integers*) returns '(1 2 3 4 5 6 7 8 9 10)
(defun take (n lst)
  (unless (or (zerop n) (lazy-null lst))
    (cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))

(defun take-all (lst)
  (unless (lazy-null lst)
    (cons (lazy-car lst) (take-all (lazy-cdr lst)))))
#+end_src

**** Mapping and Searching Across Lazy Lists

#+begin_src lisp
(defun lazy-mapcar (fun lst)
  (lazy (unless (lazy-null lst)
          (cons (funcall fun (lazy-car lst))
                (lazy-mapcar fun (lazy-cdr lst))))))

(defun lazy-mapcan (fun lst)
  (labels ((f (lst-cur)
             (if (lazy-null lst-cur)
                 (force (lazy-mapcan fun (lazy-cdr lst)))
                 (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))
    (lazy (unless (lazy-null lst)
            (f (funcall fun (lazy-car lst)))))))

(defun lazy-find-if (fun lst)
  (unless (lazy-null lst)
    (let ((x (lazy-car lst)))
      (if (funcall fun x)
          x
          (lazy-find-if fun (lazy-cdr lst))))))

(defun lazy-nth (n lst)
  (if (zerop n)
      (lazy-car lst)
      (lazy-nth (1- n) (lazy-cdr lst))))
#+end_src

*** Dice of Doom, Version 2
**** Commented source code in dice-of-doom-v2.lisp
** Chapter 19 and 20

I read these, but I didn't follow along with code, because it was using the
web server, which I couldn't get to work properly or get any help on from
StackOverflow.  Not sure why the web server is acting weird, but all this
code is ten years old, so it's surprising the rest all works so well.

