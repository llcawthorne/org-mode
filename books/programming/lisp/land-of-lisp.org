* I - Lisp is Power
** Getting Started with Lisp
*** Two main dialects of Lisp
**** Common Lisp; what this book will focus on
**** Scheme
*** Common Lisp is a multiparadigm language
*** Install CLISP to work along with book
*** If you make a mistake in the repl, just type :q
** Creating Your First Lisp Program
*** Create new top-level definitions (global vars) with =defparameter=

#+begin_src lisp
(defparameter *small* 1)
(defparameter *big* 100)
#+end_src
**** Name global variables with earmuffs: *foo*
**** =defparameter= will overwrite existing variables with the same name
**** Define global variables with =defvar= and it won't overwrite previous vars
*** Define functions with =defun=

#+begin_src lisp
(defun function_name (arguments)
  ...)
#+end_src
*** =ash= is the arithmetic shift function
**** (ash (+ *big* *small*) -1) is the average of *big* and *small*
**** it is commonly used for binary searches
*** =setf= is used to change the value of variable

#+begin_src lisp
(setf *big* (1- (guess-my-number)))

(setf *small* (1+ (guess-my-number)))
#+end_src
*** Define local variables with =let=

#+begin_src lisp
(let ((a 5)
      (b 6))
  (+ a b))
;; -> 11
#+end_src
*** Define local functions with =flet=

#+begin_src lisp
(flet ((f (n)
          (+ n 10))
       (g (n)
          (- n 3)))
  (g (f 5)))
;; -> 12
#+end_src
*** Make function names available in defined functions with =labels=

#+begin_src lisp
;; below function b calls a, so we needed labels
;; labels is also needed for recursion
(labels ((a (n)
            (+ n 5))
         (b (n)
            (+ (a n) 6)))
  (b 10))
;; -> 21
#+end_src
** Exploring the Syntax of Lisp Code
*** *Syntax* represents the rules needed to be followed to be valid in a language
**** Having simple syntax is a defining feature of Lisp
**** Parentheses are there to keep the amount of syntax to a minimum
*** *Semantics* is the meaning of something
**** You can write code with similar semantics (meaning) in most languages
*** Basic datatypes in Lisp
**** Symbols: any stand-alone word
***** letters, numbers, and characters like + = / * = < > ? ! _
***** case insensitive
**** Numbers: floating point or integer (based on decimal point present or not)
***** 1 and 1.0 are two different numbers
***** integers are upconverted to float in mixed math
***** division of integers returns a rational number
**** Strings: characters surrounded by double quotes
***** escape special characters (like ") with a backslash ("\"stop!\"")
*** Two reader modes
**** Code mode

The default mode of the reader.  Try to evaluate the head of a list as a
function applied to the rest of the list as arguments.  It also tries to
evaluate symbols, unless you prefix them with ' to enable data mode.

**** Data mode

Switch to data mode by prefixing with quote: '(1 2 3)

*** Lists in Lisp
**** cons

You can =cons= any item on to another, but you normally cons on to a list.
Note that both nil and 'nil act as the empty list.  nil is the list
terminator in Lisp.  When Lispers talk about using =cons=, they say
they are /consing/ something.

#+begin_src lisp
(cons 'chicken 'cat) ;; => (CHICKEN . CAT)
(cons 'chicken nil)  ;; => (CHICKEN)
(cons 'chicken ())   ;; => (CHICKEN)
(cons 'chicken '(1 2) ;; => (CHICKEN 1 2)
(cons 'chicken (cons 1 (cons 2 ()))) ;; => (CHICKEN 1 2)
#+end_src

A list is a series of cons cells containing and element of the list and
a pointer to the rest of the list.

**** car

=car= returns the head of a list.  It is also called =first=.
It basically takes the element out of the first cons cell and
removes the cell, leaving the rest of the list.

#+begin_src lisp
(car '(beef chicken)) ;; -> BEEF
#+end_src

**** cdr

=cdr= returns everything except the head of the list.  It is also called =rest=
It returns the rest of the list pointed to in the second part of the cons cell.

#+begin_src lisp
(cdr '(pork beef chicken)) ;; -> (BEEF CHICKEN)
(car (cdr '(pork beef chicken))) ;; -> BEEF
#+end_src
**** cadr, caddr, caaddr, and more

=cadr= returns the =car= of the =cdr= of a list. There are more combinations
of =car= and =cdr= defined standard.  Like =caddr=.  You can use any function
of the form c*r up to four levels deep.  =cadadr= is already defined (four
levels deep), but =cadadar= is not (five levels deep).

#+begin_src lisp
(cadr '(pork beef chicken)) ;; -> BEER
(caadr '((beef pork) (chicken sammich)) ;; -> CHICKEN
(cadddr '(beef pork chicken sammich) ;; -> SAMMICH
#+end_src
**** list

=list= is a convenience function that will create a list out of several items
without you having to manually cons it together.  the list is the same as if
you had defined it from multiple calls to =cons= or defined it literally with
a quote ' in front.

#+begin_src lisp
(list 'pork 'beef 'chicken) ;; -> (PORK BEEF CHICKEN)
#+end_src
**** you can nest lists

#+begin_src lisp
(car '((peas carrots tomatoes) (pork beef chicken)))
;; -> (PEAS CARROTS TOMATOES)
(cdr car '((peas carrots tomatoes) (pork beef chicken)))
;; -> (CARROTS TOMATOES)
(cdar '((pea carrots tomatoes) (pork beef chicken)))
;; -> (CARROTS TOMATOES)
(cddr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> (DUCK)
(caddr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> DUCK
(cddar '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> (TOMATOES)
(cadadr '((peas carrots tomatoes) (pork beef chicken) duck))
;; -> BEEF
#+end_src
* II - Lisp is Symmetry
** Make Decisions with Conditions
*** The Symmetry of nil and ()
**** Empty Equals False

In Clojure, we would have to check =null list= or =seq list= to get False.
Everything is "truthy" in Clojure except =nil= and =false=, but =nil= is not
just an alias for the empty list (although you can =cons= items on to =nil=
to start lists).

**** A list containing an item is True
**** A typical list-eating function

#+begin_src lisp
(defun my-length (list)
  (if list
    (1+ (my-length (cdr list)))
    0))
#+end_src

**** The Four Disguises of ()
***** '()
***** 'nil
***** nil
***** ()
***** Any value not equivalent to () is true
***** This doesn't work the same in Scheme (or Clojure)
*** The Conditionals: if and Beyond
**** =if= makes different things happen when conditions are true

#+begin_src lisp
(if (= (+ 1 2) 3)
    'yup
    'nope)
;; -> YUP

(if (oddp 5)
    'odd-number
    'even-number)
;; -> ODD_NUMBER

(if '()
    'the-list-has-stuff-in-it
    'the-list-is-empty)
;; -> THE-LIST-IS-EMPTY
#+end_src)

**** =if= is a /special form/; it doesn't evaluate both branches
**** to do more than one thing in a branch, sequence actions with =progn=

#+begin_src lisp
(defvar *number-was-odd* nil)

(if (oddp 5)
    (progn (setf *number-was-odd* t)
           'odd-number)
    'even-number)
;; -> ODD-NUMBER
> *number-was-odd*
;; -> T
#+end_src
**** =when= and =unless= contain a built-in =progn=

With =when=, all enclosed expressions are evaluated when the condition
is true.  With =unless=, all enclosed expressions are evaluated when the
condition is false.  Unlike =if=, there is no alternate branch.  They return
=nil= when the condition is the opposite value and do nothing.

#+begin_src lisp
(defvar *number-is-odd* nil)
(when (oddp 5)
      (setf *number-is-odd* t)
      'odd-number)
;; -> ODD-NUMBER
> *number-is-odd*
;; -> T

(unless (oddp 4)
        (setf *number-is-odd* nil)
        'even-number)
;; -> EVEN-NUMBER
> *number-is-odd*
;; -> NIL
#+end_src
**** the =cond= form is the classic way to do branching in Lisp

=cond= has a baked in =prog=, can handle more than one branch, and can
evaluate several conditions in succession. Note that it has more parentheses
than the Clojure version of =cond=.

#+begin_src lisp
(defvar *arch-enemy* nil)
(defun pudding-eater (person)
       (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
                                 '(curse you lisp alien - you at my pudding))
             ((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
                                  '(i hope you choked on my pudding johnny))
             (t                   '(why you eat my pudding stranger?))))
> (pudding-eater 'johnny)
;; -> (I HOPE YOU CHOKED ON MY PUDDING JOHNNY)
> *arch-enemy*
JOHNNY
#+end_src
**** =case= lets you supply a value to be compared with =eq=

Note: the case command uses =eq= for comparisons, so it is usually used
for branching on symbol values. It cannot be used to branch on string
values, among other things. We will look at comparing stuff with eq,
equal, and more later in the book.

#+begin_src lisp
(defun pudding-eater (person)
       (case person
             ((henry)   (setf *arch-enemy* 'stupid-lisp-alien)
                        '(curse you lisp alien - you ate my pudding))
             ((johnny)  (setf *arch-enemy* 'useless-old-johnny)
                        '(i hope you choked on my pudding johnny))
             (otherwise '(why you eat my pudding stranger?))))
#+end_src

**** =and= and =or= are stealth conditionals

=and= and =or= are simple mathematical operators that act as stealth
conditionals. Lisp uses /shortcut Boolean evaluation/, so that once it
determines the statement is true for =or= or false for =and=, it no longer
evaluates the remaining statements.

#+begin_src lisp
(and (oddp 5) (oddp 7) (oddp 9))
;; -> T
(or (oddp 4) (oddp 7) (oddp 8))
;; -> T

(defparameter *is-it-even* nil)
(or (oddp 4) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> T
(defparameter *is-it-even* nil)
(or (oddp 5) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> NIL

;; a real world example
(and *file-modified* (ask-user-about-saving) (save-file))
#+end_src

**** Using Functions That Return More than Just the Truth

Since any non-nil value evaluates to true, we often return something other
than true from functions.  =member= returns the rest of the list starting from
the matching item, and =find-if= returns the item it found.  An unfortunate
side effect of this is that you can't use =find-if= with =null= in a condition.

#+begin_src lisp
(member 1 '(3 4 1 5))
;; -> (1 5)
(if (member 1 '(3 4 1 5))
    'one-is-in-the-list
    'one-is-not-in-the-list)
;; -> 'ONE-IS-IN-THE-LIST

(find-if #'oddp '(2 4 5 6))
;; -> 5
(if (find-if #'oddp '(2 4 5 6))
    'there-is-an-odd-number
    'there-is-no-odd-number)
;; -> 'THERE-IS-AN-ODD-NUMBER
#+end_src

**** Comparing Stuff: eq, equal, and More
***** Conrad's Rule of Thumb for Comparing Stuff
****** Use =EQ= to compare symbols
****** Use =EQUAL= for everything else
***** Use =eq= to compare symbols
***** =equal= will tell you when two things "look the same"
***** =eql= compares symbols, numbers, and characters
***** =equalp= is like =equal= with a few twists

=equalp= can compare strings with different case, and it can compare
integers with floating point values.  Otherwise, it is like =equal=.

***** The remaining comparisons are like =equal= for certain datatypes

= only works for numbers, =string-equal= handles strings, =char-equal=
works for characters.

** Building a Text Game Engine
*** Functional Style

Functions written in a /functional programming/ style will reference only
parameters or variables declared in or passed to the function itself, and
will do nothing besides return a value. A function in this style will always
return the same result, as long as the same values are given as parameters.
In our game this chapter, =look= and =walk= are not functional because they
relies on or change global variables.

*** Association Lists

We'll talk about this a lot more in Chapter 7, but here's one in use:

#+begin_src lisp
(defparameter *nodes* '((living-room (you are in the living-room.
                                      a wizard is snoring loudly on the couch.))
                        (garden (you are in a beautiful garden.
                                 there is a well in front of you.))
                        (attic (you are in the attic.
                                there is a giant welding torch in the corner))))

(defun describe-location (location nodes)
  (cadr (assoc location nodes)))

(describe-location 'living-room *nodes*)
;; -> (YOU ARE IN A LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH).)
#+end_src

*** Quasiquoting

Quasiquoting allows you to create chunks of data that have small pieces
of Lisp code embedded in them. It uses ` and , Both the ' and ` flip us into
data mode, but ` can be unquoted using the , character to flip back to code
mode.

#+begin_src lisp
(defparameter *edges* '((living-room (garden west door)
                         (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))

(defun describe-path (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))
#+end_src

*** =mapcar=

=mapcar= will apply a function to every member of a list.

#+begin_src lisp
(mapcar #'car '((foo bar) (baz qux)))
;; -> (foo baz)

(mapcar #'describe-path '((GARDEN WEST DOOR) (ATTIC UPSTAIR LADDER)))
;; -> ((THERE IS A DOOR GOING WEST FROM HERE.))
;;     (THERE IS A LADDER GOING UPSTAIRS FROM HERE.))
#+end_src
*** #' is short-hand for the =function= operator

Unlike Scheme, Common Lisp has a namespace for functions and another for
variables. That's why we use #' to refer to a function name.  Because of
this difference in namespace, Scheme is a Lisp-1 and Common Lisp is a Lisp-2.

*** =apply= let's you give it a function and a list containing arguments

#+begin_src lisp
(apply #'append '((mary had) (a) (little lamb)))
;; -> (MARY HAD A LITTLE LAMB)
#+end_src
** Interacting with the World: Reading and Printing in Lisp
*** Printing and Reading Text
**** use =print= to print stuff to the console on its own line

=print= and =prin1= both print Lisp data structures. Strings are in quotes
and symbols are in all caps. Numbers look pretty normal. Characters look
like #\j.

**** multiple calls to =prin1= print stuff on the same line

The 1 means keep it on 1 line. Normal =print= precedes its output with a
newline and follows it with a space.

**** the =read= function lets the user enter something into the program

=read= reads Lisp data structures.  You need to surround strings with quotes.
A string without quotes is interpreted as a symbol. It will read numbers as
numbers or floats.

#+begin_src lisp
(defun say-hello ()
       (print "Please type your name:")
       (let ((name (read)))
            (print "Nice to meet you, ")
            (print name)))
#+end_src)

**** A character in lisp is #\j

Some special characters include #\newline, #\tab, and #\space

**** =princ= prints stuff for humans, it doesn't insert newline

=princ= leaves off the quotes from strings and the #\ from characters.

**** =read-line= reads a string as input, up to a newline

Read line will read the name as a string and take everything up to the newline
into the name variable.

#+begin_src lisp
(defun say-hello ()
       (princ "Please type your name:")
       (let ((name (read-line)))
            (princ "Nice to meet you, ")
            (princ name)))
#+end_src
*** The Symmetry Between Code and Data in Lisp
**** Lisp is /homoiconic/; it uses the same data structures for code and data
**** =eval= reads data as code

Warning: Inexperienced use of =eval= can pose a security risk!

#+begin_src lisp
;; let's store a chunk of data in a variable
(defparameter *foo* '(+ 1 2))
;; what if we want to execute that code.  =eval=
(eval *foo*)
;; -> 3
#+end_src

**** A Simple Custom REPL

A REPL literally only takes =read=, =eval=, =print=, and =loop=!
=read= reads the command as a symbol, =eval= evaluates it as a function,
=print= outputs what the function returns, loop makes it do it over and over.

#+begin_src lisp
(defun game-repl ()
  (loop (print (eval (read)))))
> (game-repl)
(look)

(YOU ARE IN THE LIVING-ROOM)...
#+end_src

**** A More Customized REPL
***** =game-repl=

Our goal is to be able to type "look" and "walk east" and do the game commands.
First we capture cmd using game-read, so we can see if the command is 'QUIT,
instead of making the user exit with Ctrl+C.  Then we eval and print, but
with custom versions we'll write shortly.  Finally, the game-repl calls itself.

#+begin_src lisp
(defun game-repl ()
  (let ((cmd (game-read)))
    (unless (eq (car cmd) 'quit)
      (game-print (game-eval cmd))
      (game-repl))))
#+end_src

***** =game-read=

=read= has two things we need to fix. First, we don't want to have to type
our command in parentheses, so we'll =read-line= a string then add our
parentheses afterwards. Also with read, we needed a quote in front of any
function commands. We should be able to type "walk east" without a quote
in front of east, so again, we'll take in a string and modify it by adding
the quote after the user enters it.

=read-from-string= works like =read= but it reads a syntax expression or other
Lisp datatype from a string instead of directly from the console. We are going
to tweak our string from =read-line= by =concatenate='ing quotes around it.
The result in =cmd= is that when someone types "walk east", we end up with
(walk east) in =cmd=. But we're going to pull off the =cdr= of =cmd= and map
=quote-it= across, so we end up with (walk 'east), which is what we had to
type in the REPL last chapter.  =(list 'quote 'east)= is equal to 'EAST.
(Unlike (list 'east), which equals (EAST)). We are quoting the raw parameter
by putting it in a list with =quote= command in front. =quote= is the head of
the list, so it gets evaluated to return 'EAST, which gets put back in our
initial list and gets the function call cons'ed on to the head of it.

#+begin_src lisp
(defun game-read ()
       (let ((cmd (read-from-string
                       (concatenate 'string "(" (read-line) ")"))))
       (flet ((quote-it (x)
                    (list 'quote x)))
            (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
> (game-read)
walk east
;; -> (WALK 'EAST)
#+end_src

***** =game-eval=

The main problem with =eval= is it would let the player run any Lisp command,
even one unrelated to the game. So we're going to write an =eval= that only
allows certain commands to be called.

#+begin_src lisp
(defparameter *allowed-commands* '(look walk pickup inventory))

(defun game-eval (sexp)
       (if (member (car sexp) *allowed-commands*)
           (eval sexp)
         '(i do not know that command.)))
#+end_src

***** =game-print=

Finally, let's get our output out of all uppercase, and out of parentheses.
First =prin1-to-string= will print our list of symbols to a string, then we'll
=string-trim= away the parentheses then coerce it to a list.  At this point it
looks something like this:

#+begin_src lisp
> (coerce (string-trim "() " (prin1-to-string '(a beautiful garden))) 'list)
;; -> (#\A #\Space #\B #\E #\A #\U #\T #\I #\F #\U #\L #\Space #\G #\A #\R #\D #\E #\N)
#+end_src

The only reason the list parentheses are there is because it is =coerce='d to a
list, and as you see it is a list of characters. We feed this to =tweak-text=
along with a t since the first letter should be capitalized and a =nil= for lit.
After =tweak-text= is done with it, we =coerce= it back to a string.  If we
were to =coerce= what we had above to a string without tweaking it, we would
get "A BEAUTIFUL GARDEN".

=tweak-text= processes our list of characters. It uses =cond= to check for
different conditions. First it checks if the char is a space and if so leaves
it unchanged and processes the next item. Next it checks if it is a sentence
terminator, and if so makes a not to capitalize the next character. If it's a
quote, we eliminate it and flip the lit parameter which interprets characters
literally and doesn't let us drop down to the capitalization rules. This let's
us handle some uncommon situations in our symbols, like "iPad" or "comma,".
When lit is set, it just =cons='s the unmodified char back on to the list.
Next we see if we have caps, and if so =cons= the =char-upcase= of the item on
to the rest of the list. And finally, for a normal character, we =cons= the
=char-downcase= of the item on to the rest of the list. I don't really
understand why we =or= caps and lit, since if lit was true, we wouldn't make it
to the =or= line. It seems like we only need to test caps.

#+begin_src lisp
(defun tweak-text (lst caps lit)
  (when lst
    (let ((item (car lst))
          (rest (cdr lst)))
      (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
            ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
            ((eq item #\") (tweak-text rest caps (not lit)))
            (lit (cons item (tweak-text rest nil lit)))
            ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
            (t (cons (char-downcase item) (tweak-text rest nil nil)))))))

(defun game-print (lst)
  (princ (coerce (tweak-text (coerce (string-trim "() "
                                                  (prin1-to-string lst))
                                     'list)
                             t
                             nil)
                 'string))
  (fresh-line))
#+end_src
**** The Dangers of =read= and =eval=

Despite us only executing functions from a whitelist, we are still vulnerable
to attacks involving reader macros. So as general advice, you should try not
to rely on =read= and =eval= in production Lisp code.

** Lambda: A Function So Important It Deserves Its Own Chapter
*** =lambda= lets you create a function without giving it a name
** Going Beyond Basic Lists
*** Dotted Lists

A list in Lisp that ends in something other than a =nil= is referred
to as a dotted list.

#+begin_src lisp
;; What if we cons a number onto another number instead of a list?
(cons 1 (cons 2 3))
;; -> (1 2 . 3)
#+end_src
*** Pairs

A pair is a dotted list of length 2.

#+begin_src lisp
(cons 2 3)
;; -> (2 . 3)
#+end_src

*** Circular Lists

The final cons cell of a list can point back at its head!

#+begin_src lisp
;; before playing with circular lists, run this
(setf *print-circle* t)

(defparameter foo '(1 2 3))
;; we're going to make an infinite list of (1 2 3 1 2 3 1 2 3 ...)
(setf (cdddr foo) foo)
;; -> #1=(1 2 3 . #1)#)
#+end_src

*** Association Lists (alists)

An alist consists of key/value pairs stored in a list.  By convention, if a key
appears multiple times in a list, it is assumed the first appearance of the key
contains the desired value.  Alists are commonly used but are not very efficient
for dealing with more than a dozen or so items, so are often replaced with
other data structures as a program matures.

#+begin_src lisp
(defparameter *drink-order* '((bill . double-espresso)
                              (lisa . small-drip-coffee)
                              (john . medium-latte)))
> (assoc 'lisa *drink-order*)
;; -> (LISA . SMALL-DRIP-COFFEE)

;; push adds an item to an alist.  first match is returned by assoc
(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
;; -> ((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
;;     (BILL . DOUBLE-ESPRESSO)
;;     (LISA . SMALL-DRIP-COFFEE)
;;     (JOHN . MEDIUM-LATTE))

> (assoc 'lisa *drink-order*)
;; -> (LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
#+end_src
*** Coping with Complicated Data
**** Visualizing Tree-like Data

Lists are elegant for storing trees.

#+begin_src lisp
(defparameter *house* '((walls (mortar (cement)
                                       (water)
                                       (sand))
                               (bricks))
                        (windows (glass)
                                 (frame)
                                 (curtains))
                        (roof (shingles)
                              (chimney))))
#+end_src

**** Visualizing Graphs

Graphs can be stored in cons cells, but they are difficult to visualize.  It's
hard to get a decent understanding of the structure of the game world from the
following:

#+begin_src lisp
(defparameter *wizard-nodes* '((living-room (you are in the living-room.
                                a wizard is snoring loudly on the couch.))
                               (garden (you are in a beautiful garden.
                                there is a well in front of you.))
                               (attic (you are in the attic.  there
                                is a giant welding torch in the corner.))))
(defparameter *wizard-edges* '((living-room (garden west door)
                                            (attic upstairs ladder))
                               (garden (living-room east door))
                               (attic (living-room downstairs ladder))))
#+end_src

***** Graphviz to the Rescue!
****** Converting Node Identifiers

A Graphviz identifier or a node can contain only letters, digits, and the
underscore character.  We'll replace non-alphanumeric characters with _.

#+begin_src lisp
(defun dot-name (exp)
  (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))

> (dot-name 'living-room)
;; -> "LIVING_ROOM"
> (dot-name 'foo!)
;; -> "FOO_"
#+end_src

****** Adding Labels to Graph Nodes

The label will consist of the node name and the data linked to the node in the
node alist.  We're going to limit it to 30 characters.

#+begin_src lisp
(defparameter *max-label-length* 30)

(defun dot-label (exp)
  (if exp
    (let ((s (write-to-string exp :pretty nil)))
      (if (> (length s) *max-label-length*)
             (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
          s))
    ""))
#+end_src

****** Generating the DOT Information for the Nodes

Now that we can generate a name and label for each node we can write a function
that takes an alist of nodes and generates the DOT information that encodes
them.  Note: =mapc= is like =mapcar= except it doesn't return the transformed
list.  We don't need the return value, since we're calling =princ=.

#+begin_src lisp
(defun nodes->dot (nodes)
  (mapc (lambda (node)
          (fresh-line)
          (princ (dot-name (car node)))
          (princ "[label=\"")
          (princ (dot-label node))
          (princ "\"];"))
    nodes))
#+end_src

****** Converting Edges into DOT Format

Next, we need DOT information for the edges that link our nodes.  They will
become the arrows in the output.

#+begin_src lisp
(defun edges->dot (edges)
  (mapc (lambda (node)
    (mapc (lambda (edge)
            (fresh-line)
            (princ (dot-name (car node)))
            (princ "->")
            (princ (dot-name (car edge)))
            (princ "[label=\"")
            (princ (dot-label (cdr edge)))
            (princ "\"];"))
          (cdr node)))
    edges))
#+end_src

****** Generating All the DOT Data

To complete our generation of the DOT data, we call both =nodes->dot= and
=edges->dot= and wrap it up with some extra decoration.

#+begin_src lisp
(defun graph->dot (nodes edges)
  (princ "digraph{")
  (nodes->dot nodes)
  (edges->dot edges)
  (princ "}"))
#+end_src

****** Turning the DOT File into a Picture

We are going to capture the DOT file data, put it into a file, then execute
the dot command through the command line.  It is common in Lisp to create
small functions that have zero arguments.  They are officially called
/nullary functions/.  Lispers will often create them in order to describe
a computation they don't want to run until later.  In this scenario, they are
commonly called a /thunk/ or a /suspension/.  In this case, the thunk is a
function that when called prints a DOT file to the console: =graph->dot=.
Because =graph->dot= prints directly to the console, we can't pass its return
value to =dot->png=, so instead we pass =graph->dot= as a thunk and =dot->png=
calls it, captures the results, and sends them to a file.  By calling our
stream we setup in =with-open-file= below *standard-output*, we capture output
to the console and redirect it to fname.

#+begin_src lisp
(defun dot->png (fname thunk)
  (with-open-file (*standard-output*
                   fname
                   :direction :output
                   :if-exists :supersede)
    (funcall thunk))
  (ext:shell (concatenate 'string "dot -Tpng -O " fname)))
#+end_src

****** Creating a Picture of Our Graph

Finally, we need a function that ties together all the pieces to let us
easily create a graph from some nodes and edges:

#+begin_src lisp
(defun graph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (graph->dot nodes edges))))
#+end_src)

****** Creating Undirected Graphs

It is also easy to create undirected graphs with Graphviz.  The following
code is similar to what we've seen, but makes an undirected graph.

#+begin_src lisp
(defun uedges->dot (edges)
  (maplist (lambda (lst)
             (mapc (lambda (edge)
                     (unless (assoc (car edge) (cdr lst))
                       (fresh-line)
                       (princ (dot-name (caar lst)))
                       (princ "--")
                       (princ (dot-name (car edge)))
                       (princ "[label=\"")
                       (princ (dot-label (cdr edge)))
                       (princ "\"];")))
               (cdar lst)))
    edges))

(defun ugraph->dot (nodes edges)
  (princ "graph{")
  (nodes->dot nodes)
  (uedges->dot edges)
  (princ "}"))

(defun ugraph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (ugraph->dot nodes edges))))
#+end_src)

** This Ain't Your Daddy's Wumpus
