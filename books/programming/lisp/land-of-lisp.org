
* II - Lisp is Symmetry
** Make Decisions with Conditions
*** The Symmetry of nil and ()
**** Empty Equals False

In Clojure, we would have to check =null list= or =seq list= to get False.
Everything is "truthy" in Clojure except =nil= and =false=, but =nil= is not
just an alias for the empty list (although you can =cons= items on to =nil=
to start lists).

**** A list containing an item is True
**** A typical list-eating function

#+begin_src lisp
(defun my-length (list)
  (if list
    (1+ (my-length (cdr list)))
    0))
#+end_src

**** The Four Disguises of ()
***** '()
***** 'nil
***** nil
***** ()
***** Any value not equivalent to () is true
***** This doesn't work the same in Scheme (or Clojure)
*** The Conditionals: if and Beyond
**** =if= makes different things happen when conditions are true

#+begin_src lisp
(if (= (+ 1 2) 3)
    'yup
    'nope)
;; -> YUP

(if (oddp 5)
    'odd-number
    'even-number)
;; -> ODD_NUMBER

(if '()
    'the-list-has-stuff-in-it
    'the-list-is-empty)
;; -> THE-LIST-IS-EMPTY
#+end_src)

**** =if= is a /special form/; it doesn't evaluate both branches
**** to do more than one thing in a branch, sequence actions with =progn=

#+begin_src lisp
(defvar *number-was-odd* nil)

(if (oddp 5)
    (progn (setf *number-was-odd* t)
           'odd-number)
    'even-number)
;; -> ODD-NUMBER
> *number-was-odd*
;; -> T
#+end_src
**** =when= and =unless= contain a built-in =progn=

With =when=, all enclosed expressions are evaluated when the condition
is true.  With =unless=, all enclosed expressions are evaluated when the
condition is false.  Unlike =if=, there is no alternate branch.  They return
=nil= when the condition is the opposite value and do nothing.

#+begin_src lisp
(defvar *number-is-odd* nil)
(when (oddp 5)
      (setf *number-is-odd* t)
      'odd-number)
;; -> ODD-NUMBER
> *number-is-odd*
;; -> T

(unless (oddp 4)
        (setf *number-is-odd* nil)
        'even-number)
;; -> EVEN-NUMBER
> *number-is-odd*
;; -> NIL
#+end_src
**** the =cond= form is the classic way to do branching in Lisp

=cond= has a baked in =prog=, can handle more than one branch, and can
evaluate several conditions in succession. Note that it has more parentheses
than the Clojure version of =cond=.

#+begin_src lisp
(defvar *arch-enemy* nil)
(defun pudding-eater (person)
       (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
                                 '(curse you lisp alien - you at my pudding))
             ((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
                                  '(i hope you choked on my pudding johnny))
             (t                   '(why you eat my pudding stranger?))))
> (pudding-eater 'johnny)
;; -> (I HOPE YOU CHOKED ON MY PUDDING JOHNNY)
> *arch-enemy*
JOHNNY
#+end_src
**** =case= lets you supply a value to be compared with =eq=

Note: the case command uses =eq= for comparisons, so it is usually used
for branching on symbol values. It cannot be used to branch on string
values, among other things. We will look at comparing stuff with eq,
equal, and more later in the book.

#+begin_src lisp
(defun pudding-eater (person)
       (case person
             ((henry)   (setf *arch-enemy* 'stupid-lisp-alien)
                        '(curse you lisp alien - you ate my pudding))
             ((johnny)  (setf *arch-enemy* 'useless-old-johnny)
                        '(i hope you choked on my pudding johnny))
             (otherwise '(why you eat my pudding stranger?))))
#+end_src

**** =and= and =or= are stealth conditionals

=and= and =or= are simple mathematical operators that act as stealth
conditionals. Lisp uses /shortcut Boolean evaluation/, so that once it
determines the statement is true for =or= or false for =and=, it no longer
evaluates the remaining statements.

#+begin_src lisp
(and (oddp 5) (oddp 7) (oddp 9))
;; -> T
(or (oddp 4) (oddp 7) (oddp 8))
;; -> T

(defparameter *is-it-even* nil)
(or (oddp 4) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> T
(defparameter *is-it-even* nil)
(or (oddp 5) (setf *is-it-even* t))
;; -> T
> *is-it-even*
;; -> NIL

;; a real world example
(and *file-modified* (ask-user-about-saving) (save-file))
#+end_src

**** Using Functions That Return More than Just the Truth

Since any non-nil value evaluates to true, we often return something other
than true from functions.  =member= returns the rest of the list starting from
the matching item, and =find-if= returns the item it found.  An unfortunate
side effect of this is that you can't use =find-if= with =null= in a condition.

#+begin_src lisp
(member 1 '(3 4 1 5))
;; -> (1 5)
(if (member 1 '(3 4 1 5))
    'one-is-in-the-list
    'one-is-not-in-the-list)
;; -> 'ONE-IS-IN-THE-LIST

(find-if #'oddp '(2 4 5 6))
;; -> 5
(if (find-if #'oddp '(2 4 5 6))
    'there-is-an-odd-number
    'there-is-no-odd-number)
;; -> 'THERE-IS-AN-ODD-NUMBER
#+end_src

**** Comparing Stuff: eq, equal, and More
***** Conrad's Rule of Thumb for Comparing Stuff
****** Use =EQ= to compare symbols
****** Use =EQUAL= for everything else
***** Use =eq= to compare symbols
***** =equal= will tell you when two things "look the same"
***** =eql= compares symbols, numbers, and characters
***** =equalp= is like =equal= with a few twists

=equalp= can compare strings with different case, and it can compare
integers with floating point values.  Otherwise, it is like =equal=.

***** The remaining comparisons are like =equal= for certain datatypes

= only works for numbers, =string-equal= handles strings, =char-equal=
works for characters.

** Building a Text Game Engine
*** Functional Style

Functions written in a /functional programming/ style will reference only
parameters or variables declared in or passed to the function itself, and
will do nothing besides return a value. A function in this style will always
return the same result, as long as the same values are given as parameters.
In our game this chapter, =look= and =walk= are not functional because they
relies on or change global variables.

*** Association Lists

We'll talk about this a lot more in Chapter 7, but here's one in use:

#+begin_src lisp
(defparameter *nodes* '((living-room (you are in the living-room.
                                      a wizard is snoring loudly on the couch.))
                        (garden (you are in a beautiful garden.
                                 there is a well in front of you.))
                        (attic (you are in the attic.
                                there is a giant welding torch in the corner))))

(defun describe-location (location nodes)
  (cadr (assoc location nodes)))

(describe-location 'living-room *nodes*)
;; -> (YOU ARE IN A LIVING-ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH).)
#+end_src

*** Quasiquoting

Quasiquoting allows you to create chunks of data that have small pieces
of Lisp code embedded in them. It uses ` and , Both the ' and ` flip us into
data mode, but ` can be unquoted using the , character to flip back to code
mode.

#+begin_src lisp
(defparameter *edges* '((living-room (garden west door)
                         (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))

(defun describe-path (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))
#+end_src

*** =mapcar=

=mapcar= will apply a function to every member of a list.

#+begin_src lisp
(mapcar #'car '((foo bar) (baz qux)))
;; -> (foo baz)

(mapcar #'describe-path '((GARDEN WEST DOOR) (ATTIC UPSTAIR LADDER)))
;; -> ((THERE IS A DOOR GOING WEST FROM HERE.))
;;     (THERE IS A LADDER GOING UPSTAIRS FROM HERE.))
#+end_src
*** #' is short-hand for the =function= operator

Unlike Scheme, Common Lisp has a namespace for functions and another for
variables. That's why we use #' to refer to a function name.  Because of
this difference in namespace, Scheme is a Lisp-1 and Common Lisp is a Lisp-2.

*** =apply= let's you give it a function and a list containing arguments

#+begin_src lisp
(apply #'append '((mary had) (a) (little lamb)))
;; -> (MARY HAD A LITTLE LAMB)
#+end_src
** Interacting with the World: Reading and Printing in Lisp
*** Printing and Reading Text
**** use =print= to print stuff to the console on its own line

=print= and =prin1= both print Lisp data structures. Strings are in quotes
and symbols are in all caps. Numbers look pretty normal. Characters look
like #\j.

**** multiple calls to =prin1= print stuff on the same line

The 1 means keep it on 1 line. Normal =print= precedes its output with a
newline and follows it with a space.

**** the =read= function lets the user enter something into the program

=read= reads Lisp data structures.  You need to surround strings with quotes.
A string without quotes is interpreted as a symbol. It will read numbers as
numbers or floats.

#+begin_src lisp
(defun say-hello ()
       (print "Please type your name:")
       (let ((name (read)))
            (print "Nice to meet you, ")
            (print name)))
#+end_src)

**** A character in lisp is #\j

Some special characters include #\newline, #\tab, and #\space

**** =princ= prints stuff for humans, it doesn't insert newline

=princ= leaves off the quotes from strings and the #\ from characters.

**** =read-line= reads a string as input, up to a newline

Read line will read the name as a string and take everything up to the newline
into the name variable.

#+begin_src lisp
(defun say-hello ()
       (princ "Please type your name:")
       (let ((name (read-line)))
            (princ "Nice to meet you, ")
            (princ name)))
#+end_src
*** The Symmetry Between Code and Data in Lisp
**** Lisp is /homoiconic/; it uses the same data structures for code and data
**** =eval= reads data as code

Warning: Inexperienced use of =eval= can pose a security risk!

#+begin_src lisp
;; let's store a chunk of data in a variable
(defparameter *foo* '(+ 1 2))
;; what if we want to execute that code.  =eval=
(eval *foo*)
;; -> 3
#+end_src

**** A Simple Custom REPL

A REPL literally only takes =read=, =eval=, =print=, and =loop=!
=read= reads the command as a symbol, =eval= evaluates it as a function,
=print= outputs what the function returns, loop makes it do it over and over.

#+begin_src lisp
(defun game-repl ()
  (loop (print (eval (read)))))
> (game-repl)
(look)

(YOU ARE IN THE LIVING-ROOM)...
#+end_src

**** A More Customized REPL
***** =game-repl=

Our goal is to be able to type "look" and "walk east" and do the game commands.
First we capture cmd using game-read, so we can see if the command is 'QUIT,
instead of making the user exit with Ctrl+C.  Then we eval and print, but
with custom versions we'll write shortly.  Finally, the game-repl calls itself.

#+begin_src lisp
(defun game-repl ()
  (let ((cmd (game-read)))
    (unless (eq (car cmd) 'quit)
      (game-print (game-eval cmd))
      (game-repl))))
#+end_src

***** =game-read=

=read= has two things we need to fix. First, we don't want to have to type
our command in parentheses, so we'll =read-line= a string then add our
parentheses afterwards. Also with read, we needed a quote in front of any
function commands. We should be able to type "walk east" without a quote
in front of east, so again, we'll take in a string and modify it by adding
the quote after the user enters it.

=read-from-string= works like =read= but it reads a syntax expression or other
Lisp datatype from a string instead of directly from the console. We are going
to tweak our string from =read-line= by =concatenate='ing quotes around it.
The result in =cmd= is that when someone types "walk east", we end up with
(walk east) in =cmd=. But we're going to pull off the =cdr= of =cmd= and map
=quote-it= across, so we end up with (walk 'east), which is what we had to
type in the REPL last chapter.  =(list 'quote 'east)= is equal to 'EAST.
(Unlike (list 'east), which equals (EAST)). We are quoting the raw parameter
by putting it in a list with =quote= command in front. =quote= is the head of
the list, so it gets evaluated to return 'EAST, which gets put back in our
initial list and gets the function call cons'ed on to the head of it.

#+begin_src lisp
(defun game-read ()
       (let ((cmd (read-from-string
                       (concatenate 'string "(" (read-line) ")"))))
       (flet ((quote-it (x)
                    (list 'quote x)))
            (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))
> (game-read)
walk east
;; -> (WALK 'EAST)
#+end_src

***** =game-eval=

The main problem with =eval= is it would let the player run any Lisp command,
even one unrelated to the game. So we're going to write an =eval= that only
allows certain commands to be called.

#+begin_src lisp
(defparameter *allowed-commands* '(look walk pickup inventory))

(defun game-eval (sexp)
       (if (member (car sexp) *allowed-commands*)
           (eval sexp)
         '(i do not know that command.)))
#+end_src

***** =game-print=

Finally, let's get our output out of all uppercase, and out of parentheses.
First =prin1-to-string= will print our list of symbols to a string, then we'll
=string-trim= away the parentheses then coerce it to a list.  At this point it
looks something like this:

#+begin_src lisp
> (coerce (string-trim "() " (prin1-to-string '(a beautiful garden))) 'list)
;; -> (#\A #\Space #\B #\E #\A #\U #\T #\I #\F #\U #\L #\Space #\G #\A #\R #\D #\E #\N)
#+end_src

The only reason the list parentheses are there is because it is =coerce='d to a
list, and as you see it is a list of characters. We feed this to =tweak-text=
along with a t since the first letter should be capitalized and a =nil= for lit.
After =tweak-text= is done with it, we =coerce= it back to a string.  If we
were to =coerce= what we had above to a string without tweaking it, we would
get "A BEAUTIFUL GARDEN".

=tweak-text= processes our list of characters. It uses =cond= to check for
different conditions. First it checks if the char is a space and if so leaves
it unchanged and processes the next item. Next it checks if it is a sentence
terminator, and if so makes a not to capitalize the next character. If it's a
quote, we eliminate it and flip the lit parameter which interprets characters
literally and doesn't let us drop down to the capitalization rules. This let's
us handle some uncommon situations in our symbols, like "iPad" or "comma,".
When lit is set, it just =cons='s the unmodified char back on to the list.
Next we see if we have caps, and if so =cons= the =char-upcase= of the item on
to the rest of the list. And finally, for a normal character, we =cons= the
=char-downcase= of the item on to the rest of the list. I don't really
understand why we =or= caps and lit, since if lit was true, we wouldn't make it
to the =or= line. It seems like we only need to test caps.

#+begin_src lisp
(defun tweak-text (lst caps lit)
  (when lst
    (let ((item (car lst))
          (rest (cdr lst)))
      (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
            ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
            ((eq item #\") (tweak-text rest caps (not lit)))
            (lit (cons item (tweak-text rest nil lit)))
            ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
            (t (cons (char-downcase item) (tweak-text rest nil nil)))))))

(defun game-print (lst)
  (princ (coerce (tweak-text (coerce (string-trim "() "
                                                  (prin1-to-string lst))
                                     'list)
                             t
                             nil)
                 'string))
  (fresh-line))
#+end_src
**** The Dangers of =read= and =eval=

Despite us only executing functions from a whitelist, we are still vulnerable
to attacks involving reader macros. So as general advice, you should try not
to rely on =read= and =eval= in production Lisp code.

** Lambda: A Function So Important It Deserves Its Own Chapter
*** =lambda= lets you create a function without giving it a name
** Going Beyond Basic Lists
*** Dotted Lists

A list in Lisp that ends in something other than a =nil= is referred
to as a dotted list.

#+begin_src lisp
;; What if we cons a number onto another number instead of a list?
(cons 1 (cons 2 3))
;; -> (1 2 . 3)
#+end_src
*** Pairs

A pair is a dotted list of length 2.

#+begin_src lisp
(cons 2 3)
;; -> (2 . 3)
#+end_src

*** Circular Lists

The final cons cell of a list can point back at its head!

#+begin_src lisp
;; before playing with circular lists, run this
(setf *print-circle* t)

(defparameter foo '(1 2 3))
;; we're going to make an infinite list of (1 2 3 1 2 3 1 2 3 ...)
(setf (cdddr foo) foo)
;; -> #1=(1 2 3 . #1)#)
#+end_src

*** Association Lists (alists)

An alist consists of key/value pairs stored in a list.  By convention, if a key
appears multiple times in a list, it is assumed the first appearance of the key
contains the desired value.  Alists are commonly used but are not very efficient
for dealing with more than a dozen or so items, so are often replaced with
other data structures as a program matures.

#+begin_src lisp
(defparameter *drink-order* '((bill . double-espresso)
                              (lisa . small-drip-coffee)
                              (john . medium-latte)))
> (assoc 'lisa *drink-order*)
;; -> (LISA . SMALL-DRIP-COFFEE)

;; push adds an item to an alist.  first match is returned by assoc
(push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
;; -> ((LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
;;     (BILL . DOUBLE-ESPRESSO)
;;     (LISA . SMALL-DRIP-COFFEE)
;;     (JOHN . MEDIUM-LATTE))

> (assoc 'lisa *drink-order*)
;; -> (LISA . LARGE-MOCHA-WITH-WHIPPED-CREAM)
#+end_src
*** Coping with Complicated Data
**** Visualizing Tree-like Data

Lists are elegant for storing trees.

#+begin_src lisp
(defparameter *house* '((walls (mortar (cement)
                                       (water)
                                       (sand))
                               (bricks))
                        (windows (glass)
                                 (frame)
                                 (curtains))
                        (roof (shingles)
                              (chimney))))
#+end_src

**** Visualizing Graphs

Graphs can be stored in cons cells, but they are difficult to visualize.  It's
hard to get a decent understanding of the structure of the game world from the
following:

#+begin_src lisp
(defparameter *wizard-nodes* '((living-room (you are in the living-room.
                                a wizard is snoring loudly on the couch.))
                               (garden (you are in a beautiful garden.
                                there is a well in front of you.))
                               (attic (you are in the attic.  there
                                is a giant welding torch in the corner.))))
(defparameter *wizard-edges* '((living-room (garden west door)
                                            (attic upstairs ladder))
                               (garden (living-room east door))
                               (attic (living-room downstairs ladder))))
#+end_src

***** Graphviz to the Rescue!
****** Converting Node Identifiers

A Graphviz identifier or a node can contain only letters, digits, and the
underscore character.  We'll replace non-alphanumeric characters with _.

#+begin_src lisp
(defun dot-name (exp)
  (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))

> (dot-name 'living-room)
;; -> "LIVING_ROOM"
> (dot-name 'foo!)
;; -> "FOO_"
#+end_src

****** Adding Labels to Graph Nodes

The label will consist of the node name and the data linked to the node in the
node alist.  We're going to limit it to 30 characters.

#+begin_src lisp
(defparameter *max-label-length* 30)

(defun dot-label (exp)
  (if exp
    (let ((s (write-to-string exp :pretty nil)))
      (if (> (length s) *max-label-length*)
             (concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
          s))
    ""))
#+end_src

****** Generating the DOT Information for the Nodes

Now that we can generate a name and label for each node we can write a function
that takes an alist of nodes and generates the DOT information that encodes
them.  Note: =mapc= is like =mapcar= except it doesn't return the transformed
list.  We don't need the return value, since we're calling =princ=.

#+begin_src lisp
(defun nodes->dot (nodes)
  (mapc (lambda (node)
          (fresh-line)
          (princ (dot-name (car node)))
          (princ "[label=\"")
          (princ (dot-label node))
          (princ "\"];"))
    nodes))
#+end_src

****** Converting Edges into DOT Format

Next, we need DOT information for the edges that link our nodes.  They will
become the arrows in the output.

#+begin_src lisp
(defun edges->dot (edges)
  (mapc (lambda (node)
    (mapc (lambda (edge)
            (fresh-line)
            (princ (dot-name (car node)))
            (princ "->")
            (princ (dot-name (car edge)))
            (princ "[label=\"")
            (princ (dot-label (cdr edge)))
            (princ "\"];"))
          (cdr node)))
    edges))
#+end_src

****** Generating All the DOT Data

To complete our generation of the DOT data, we call both =nodes->dot= and
=edges->dot= and wrap it up with some extra decoration.

#+begin_src lisp
(defun graph->dot (nodes edges)
  (princ "digraph{")
  (nodes->dot nodes)
  (edges->dot edges)
  (princ "}"))
#+end_src

****** Turning the DOT File into a Picture

We are going to capture the DOT file data, put it into a file, then execute
the dot command through the command line.  It is common in Lisp to create
small functions that have zero arguments.  They are officially called
/nullary functions/.  Lispers will often create them in order to describe
a computation they don't want to run until later.  In this scenario, they are
commonly called a /thunk/ or a /suspension/.  In this case, the thunk is a
function that when called prints a DOT file to the console: =graph->dot=.
Because =graph->dot= prints directly to the console, we can't pass its return
value to =dot->png=, so instead we pass =graph->dot= as a thunk and =dot->png=
calls it, captures the results, and sends them to a file.  By calling our
stream we setup in =with-open-file= below *standard-output*, we capture output
to the console and redirect it to fname.

#+begin_src lisp
(defun dot->png (fname thunk)
  (with-open-file (*standard-output*
                   fname
                   :direction :output
                   :if-exists :supersede)
    (funcall thunk))
  (ext:shell (concatenate 'string "dot -Tpng -O " fname)))
#+end_src

****** Creating a Picture of Our Graph

Finally, we need a function that ties together all the pieces to let us
easily create a graph from some nodes and edges:

#+begin_src lisp
(defun graph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (graph->dot nodes edges))))
#+end_src)

****** Creating Undirected Graphs

It is also easy to create undirected graphs with Graphviz.  The following
code is similar to what we've seen, but makes an undirected graph.

#+begin_src lisp
(defun uedges->dot (edges)
  (maplist (lambda (lst)
             (mapc (lambda (edge)
                     (unless (assoc (car edge) (cdr lst))
                       (fresh-line)
                       (princ (dot-name (caar lst)))
                       (princ "--")
                       (princ (dot-name (car edge)))
                       (princ "[label=\"")
                       (princ (dot-label (cdr edge)))
                       (princ "\"];")))
               (cdar lst)))
    edges))

(defun ugraph->dot (nodes edges)
  (princ "graph{")
  (nodes->dot nodes)
  (uedges->dot edges)
  (princ "}"))

(defun ugraph->png (fname nodes edges)
  (dot->png fname
            (lambda ()
              (ugraph->dot nodes edges))))
#+end_src)

** This Ain't Your Daddy's Wumpus
*** Intro to the Game

    "In this new version of Hunt the Wumpus, you are the Lisp alien. You and
    the Wumpus have just robbed a liquor store and made off with the loot.
    However, during the escape, the Wumpus decides to double-cross you and
    run off with the money and your car. But before he drives off, you manage
    to cap him a couple of times in the kidney.

    Now you’re in a pretty tough situation. You don’t have a car or any money,
    and no way to track down your former partner in crime. But you also have
    no choice. You have your principles, so you’re going to /hunt the Wumpus/."

*** Playing the Game

The game is in my git repo for land-of-lisp as wumpus.lisp.  To start, you
=(load "wumpus")= then type =(new-game)=.  Then you open the known-city.png in
the directory you ran it from.  This is your auto-updating map of the city.  To
explore a node, let's say Node 17, you type =(walk 17)=.  When you think you
know the Wumpus' location, you need to charge that node, like =(charge 23)= to
win the game.  Avoid glow-worms which show lights one node away and cops which
show up as sirens on the node adjacent to the edge with cops.  The Wumpus
leaves a blood trail two nodes away from his location, due to his injuries.
Don't cheat and look at the full city.png in the directory where you started
the new-game from.

*** Full Code in wumpus.lisp, but also spread out below
*** Defining the Edges of Congestion City

Congestion City will be an undirected graph of 30 nodes and 45 edges.

#+begin_src lisp
(load "graph-utils")

(defparameter *congestion-city-nodes* nil)
(defparameter *congestion-city-edges* nil)
(defparameter *visited-nodes* nil)
(defparameter *node-num* 30)
(defparameter *edge-num* 45)
(defparameter *worm-num* 3)
(defparameter *cop-odds* 15)

;; random *node-num* will give us a number from 0 to 29 for 30 nodes
;; so we're adding 1 to it to make it 1 to 30
(defun random-node ()
  (1+ (random *node-num*)))

(defun edge-pair (a b)
  (unless (eql a b)
    (list (cons a b) (cons b a))))

(defun make-edge-list ()
  (apply #'append (loop repeat *edge-num*
                               collect (edge-pair (random-node) (random-node)))))
#+end_src))

*** Looping with the =loop= Command

Within the =loop= comman, we specify how many times to =repeat=, and then
specify an object to collect with every loop.

#+begin_src lisp
(loop repeat 10
      collect 1)
;; -> (1 1 1 1 1 1 1 1 1 1)
(loop for n from 1 to 10
      collect n)
;; -> (1 2 3 4 5 6 7 8 9 10)
(loop for n from 1 to 10
      collect (+ 100 n))
;; -> (101 102 103 104 105 106 107 108 109 110)
#+end_src

*** Prevent Islands

If we randomly generate a graph, it might not be all connected.  This code
takes the list of edges, finds unconnected nodes, and connects these islands
to the rest of the city network.  First, we need =direct-edges=, a utility
function that finds all the edges in an edge list that start from a given node.
It does this by creating a new list with all edges removed that don't have the
current node in the =car= position.  To find islands we use =get-connected=,
which takes an edge list and a source node and builds a list of all nodes
connected to that node.  =find-islands= finds all our islands, and
=connect-with-bridges= returns a list of additional edges to connect our
islands together.  =connect-all-islands= ties all these together.  It appends
the bridges from =connect-with-bridges= to the main =edge-list=.

#+begin_src lisp
(defun direct-edges (node edge-list)
  (remove-if-not (lambda (x)
                   (eql (car x) node))
                 edge-list))

(defun get-connected (node edge-list)
  (let ((visited nil))
    (labels ((traverse (node)
               (unless (member node visited)
                 (push node visited)
                 (mapc (lambda (edge)
                         (traverse (cdr edge)))
                      (direct-edges node edge-list)))))
      (traverse node))
    visited))

(defun find-islands (nodes edge-list)
  (let ((islands nil))
    (labels ((find-island (nodes)
               (let* ((connected (get-connected (car nodes) edge-list))
                      (unconnected (set-difference nodes connected)))
                 (push connected islands)
                 (when unconnected
                   (find-island unconnected)))))
      (find-island nodes))
    islands))

(defun connect-with-bridges (islands)
  (when (cdr islands)
    (append (edge-pair (caar islands) (caadr islands))
            (connect-with-bridges (cdr islands)))))

(defun connect-all-islands (nodes edge-list)
  (append (connect-with-bridges (find-islands nodes edge-list)) edge-list))
#+end_src

*** Building the Final Edges for Congestion City

=make-city-edges= creates a list of nodes, then it creates a random (but fully
connected) edge list by calling =make-edge-list= and =connect-edge-list=.
It then creates a random list of edges that have cops.  We define these using
the =let*= command, which allows us to refer to previously defined variables
from the same =let*= block.

=edges-to-alist= converts a list of edges into an alist of edges.  For example,
let's say we had nodes 1, 2, and 3, with 1 connected to 2, 2 connected to 1 and
3, and 3 connected to 2.  As a list, this would be '((1 . 2) (2 . 1) (2 . 3)
(3 . 2)).  As an alist, this would be '((1 (2)) (2 (1) (3)) (3 (2))).  To build
this alist, =edges=to-list= first =mapcar=s over the nodes in the edge list.
It builds the list of nodes with =remove-duplicates=.  Within the outer =mapcar=
we do another =mapcar= to map across all the =direct-edges= to this node.
Together, these nested =mapcar= functions allow =edges-to-alist= to convert
the edges of a city into an alist.

=add-cops= marks the edges in our alist that contain cops.  It uses nested
=mapcar= commands to map across the edges within each node.  =intersection=
tell us if items are shared between two lists.  Imagine our three node city
again, where the alist is '((1 (2)) (2 (1) (3)) (3 (2))).  Now if we put cops
between 2 and 3, it would look like '((1 (2)) (2 (1) (3 COPS)) (3 (2 COPS))).
To get all edges connected to a given node, we call =(cdr (assoc node1 edges))=,
then to see if a given edge contains cops:
=(cdr (assoc node2 (cdr (assoc node1 edges))))=, which goes down two levels to
grab the actual data linked to a specific edge between two nodes.

#+begin_src lisp
(defun make-city-edges ()
  (let* ((nodes (loop for i from 1 to *node-num*
                      collect i))
         (edge-list (connect-all-islands nodes (make-edge-list)))
         (cops (remove-if-not (lambda (x)
                                (zerop (random *cop-odds*)))
                              edge-list)))
    (add-cops (edges-to-alist edge-list) cops)))

(defun edges-to-alist (edge-list)
  (mapcar (lambda (node1)
            (cons node1
                  (mapcar (lambda (edge)
                            (list (cdr edge)))
                          (remove-duplicates (direct-edges node1 edge-list)
                                             :test #'equal))))
          (remove-duplicates (mapcar #'car edge-list))))

(defun add-cops (edge-alist edges-with-cops)
  (mapcar (lambda (x)
            (let ((node1 (car x))
                  (node1-edges (cdr x)))
              (cons node1
                    (mapcar (lambda (edge)
                              (let ((node2 (car edge)))
                                (if (intersection (edge-pair node1 node2)
                                                  edges-with-cops
                                                  :test #'equal)
                                    (list node2 'cops)
                                    edge)))
                            node1-edges))))
          edge-alist))
#+end_src

*** Building the Nodes for Congestion City

Now we need an alist for the nodes in our city.  These nodes may contains the
Wumpus or the Glowworms, or they might contain various clues, such as blood,
lights, or sirens.  Most of the clues are based on proximity with another node.
The =neighbors= function looks up a node's neighbors.

#+begin_src lisp
(defun neighbors (node edge-alist)
  (mapcar #'car (cdr (assoc node edge-alist))))

(defun within-one (a b edge-alist)
  (member b (neighbors a edge-alist)))

(defun within-two (a b edge-alist)
  (or (within-one a b edge-alist)
      (some (lambda (x)
              (within-one x b edge-alist))
            (neighbors a edge-alist))))

(defun make-city-nodes (edge-alist)
  (let ((wumpus (random-node))
        (glow-worms (loop for i below *worm-num*
                          collect (random-node))))
    (loop for n from 1 to *node-num*
          collect (append (list n)
                          (cond ((eql n wumpus) '(wumpus))
                                ((within-two n wumpus edge-alist) '(blood!)))
                          (cond ((member n glow-worms)
                                 '(glow-worm))
                                ((some (lambda (worm)
                                         (within-one n worm edge-alist))
                                       glow-worms)
                                 '(lights!)))
                          (when (some #'cdr (cdr (assoc n edge-alist)))
                            '(sirens!)))))
#+end_src

*** Initializing a New Game of Grand Theft Wumpus

We need to only show city nodes we visited and hide cops before we explore.
=mapcan= is a variant of =mapcar= that assumes that the values generated by
the mapping function are all lists that should be appended together.

#+being_src lisp
(defun new-game ()
  (setf *congestion-city-edges* (make-city-edges))
  (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
  (setf *player-pos* (find-empty-node))
  (setf *visited-nodes* (list *player-pos*))
  (draw-city)
  (draw-known-city))

(defun find-empty-node ()
  (let ((x (random-node)))
    (if (cdr (assoc x *congestion-city-nodes*))
        (find-empty-node)
        x)))

(defun draw-city ()
  (ugraph->png "city" *congestion-city-nodes* *congestion-city-edges*)):w

(defun known-city-nodes ()
  (mapcar (lambda (node)
            (if (member node *visited-nodes*)
                (let ((n (assoc node *congestion-city-nodes*)))
                  (if (eql node *player-pos*)
                      (append n '(*))
                      n))
                (list node '?)))
          (remove-duplicates
           (append *visited-nodes*
                   (mapcan (lambda (node)
                             (mapcar #'car
                                     (cdr (assoc node *congestion-city-edges*))))
                           *visited-nodes*)))))

(defun known-city-edges ()
  (mapcar (lambda (node)
            (cons node (mapcar (lambda (x)
                                 (if (member (car x) *visited-nodes*)
                                     x
                                     (list (car x))))
                               (cdr (assoc node *congestion-city-edges*)))))
          *visited-nodes*))

(defun draw-known-city ()
  (ugraph->png "known-city" (known-city-nodes) (known-city-edges)))
#+end_src

*** Walking Around Town

Walk is used to move around.  You need to charge the final location of the
Wumpus to win the game, but if you charge any non-Wumpus location, you lose.

#+begin_src lisp
(defun walk (pos)
  (handle-direction pos nil))

(defun charge (pos)
  (handle-direction pos t))

(defun handle-direction (pos charging)
  (let ((edge (assoc pos (cdr (assoc *player-pos* *congestion-city-edges*)))))
    (if edge
        (handle-new-place edge pos charging)
        (princ "That location does not exist!"))))

(defun handle-new-place (edge pos charging)
  (let* ((node (assoc pos *congestion-city-nodes*))
         (has-worm (and (member 'glow-worm node)
                        (not (member pos *visited-nodes*)))))
    (pushnew pos *visited-nodes*)
    (setf *player-pos* pos)
    (draw-known-city)
    (cond ((member 'cops edge) (princ "You ran into the cops. Game Over."))
          ((member 'wumpus node) (if charging
                                     (princ "You found the Wumpus!")
                                     (princ "You ran into the Wumpus")))
          (charging (princ "You wasted your last bullet.  Game Over."))
          (has-worm (let ((new-pos (random-node)))
                      (princ "You ran into a Glow Worm Gang!  You're now at ")
                      (princ new-pos)
                      (handle-new-place nil new-pos nil))))))
#+end_src

** Advanced Datatypes and Generic Programming
*** Arrays
**** Advantage of arrays: constant-time random access
**** Working with Arrays

Use =aref= to get an set items in an array.  =aref= with =setf= to set.

#+begin_src lisp
(make-array 3)
;; -> #(NIL NIL NIL)
(defparameter x (make-array 3))
;; -> #(NIL NIL NIL)
;; get the item at index 1 with aref
(aref x 1)
;; -> NIL
(setf (aref x 1) 'foo)
;; -> FOO
x
;; -> #(NIL FOO NIL)
(aref x 1)
;; -> FOO
#+end_src

***** An aside on =setf=

Common Lisp supports /generic setters/.  In most cases, the code for pulling an
item out of a data structure is identical to code for putting data into that
structure.  The second argument to =setf= is a /generalized reference/, which
supports a fairly complicated subset of Lisp.

#+begin_src lisp
(setf foo '(a b c))
;; -> (A B C)
(second foo)
;; -> B
(setf (second foo) 'z)
;; -> Z
foo
;; -> (A Z C)
(setf foo (make-array 4))
;; -> #(NIL NIL NIL NIL)
(setf (aref foo 2) '(x y z))
;; -> (X Y Z)
foo
;; -> #(NIL NIL (X Y Z) NIL)
(setf (car (aref foo 2)) (make-hash-table))
;; -> #S(HASH-TABLE)
(setf (gethash 'zoink (car (aref foo 2))) 5)
;; -> 5
foo
;; -> #(NIL NIL (#S(HASH-TABLE (ZOINK . 5)) Y Z) NIL)
#+end_src

*** Hash Tables
**** Like alists, except faster arbitrary element access
**** Working with Hash Tables

You'll notice below that =gethash= returns two nils.  The first nil is the
actual value stored in the hash table.  The second nil indicates whether the
key was found in the table.

#+begin_src lisp
(defparameter x (make-hash-table))
;; -> #S(HASH-TABLE ...)
(gethash 'yup x)
;; -> NIL ;
;;    NIL
(setf (gethash 'yup x) '25)
;; -> 25
(gethash 'yup x)
;; -> 25 ;
;;    T
#+end_src

***** An aside on Returning Multiple Values

Some core Lisp functions like =gethash= and =round= return multiple values.
You can return multiple values too with the =values= function.  The first
value is more important and used in follow-up calculations.  If you need the
second value, you can bind it with =multiple-value-bind=.

#+begin_src lisp
(round 2.4)
;; -> 2 ;
;;    0.4
(defun foo ()
  (values 3 7))
;; -> FOO
(foo)
;; -> 3 ;
;;    7
;; the first value is "default"
(+ (foo) 5)
;; -> 8
;; but we can access both values
(multiple-value-bind (a b) (foo)
                     (* a b))
;; -> 21
#+end_src

**** A Faster Grand Theft Wumpus Using Hash Tables

alists were fine for our 30 node, 45 edge Grand Theft Wumpus, but if we tried
with 1000 nodes and 1000 edges, it would be a lot slower.  Here's the code to
convert our edge alist to a hash table.  As you see below, we can use =push=
on hash tables too.

#+begin_src lisp
(defun hash-edges (edge-list)
  (let ((tab (make-hash-table)))
    (mapc (lambda (x)
            (let ((node (car x)))
              (push (cdr x) (gethash node tab))))
      edge-list)
    tab))

;; now we need a new version of get-connected to use the hash
(defun get-connected-hash (node edge-tab)
  (let ((visited (make-hash-table)))
    (labels ((traverse (node)
               (unless (gethash node visited)
                 (setf (gethash node visited) t)
                 (mapc (lambda (edge)
                         (traverse edge))
                   (gethash node edge-tab)))))
      (traverse node))
    visited))
#+end_src

*** Performance Testing with =time=

The only true way to tell if changing a data structure or algorithm makes
your program faster is to time your code with the =time= command.

#+begin_src lisp
(setf *edge-num* 1000)
(setf *node-num* 1000)

(time (dotimes (i 100) (get-connected 1 (make-edge-list))))
;; takes almost 60 seconds with alists, barely 1 sec with hash tables
#+end_src

*** Common Lisp Structures
**** What are Structures?

Structures can be used to represent objects with properties.

#+begin_src lisp
(defstruct person
           name
           age
           waist-size
           favorite-color)
;; -> PERSON

;; defstruct automatically creates make-person
(defparameter *bob* (make-person :name "Bob"
                                 :age 35
                                 :waist-size 42
                                 :favorite-color "blue"))
;; -> *BOB*
*bob*
;; -> #S(PERSON :NAME "Bob" :AGE 35 :WAIST-SIZE 42 :FAVORITE-COLOR "blue")

;; we can get bob's age from person-age, also automatically generated
(person-age *bob*)
;; -> 35
(setf (person-age *bob*) 36)
;; -> 36

;; the reader can also create a person from the printed representation
(defparameter *that-guy* #S(person :name "Bob" :age 35 :waist-size 42 :favorite-color "blue"))
(person-age *that-guy*)
;; -> 35
#+end_src

**** When to Use Structures

There's nothing you can do with structures that you couldn't manage with lists
and some accessor functions.  However the accessor functions are error-prone,
and the list isn't self describing like a structure.  Structures also handle
mutation better, so are better for objects likely to change.

*** Handling Data in a Generic Way
**** Working with Sequences
***** Sequences: lists, arrays, and strings

Library functions often work well with multiple types of data.  For example,
the /sequence functions/ work generically across the three main ways of
sequencing objects in Lisp: lists, arrays, and strings.  =length= can take any
of those three and return its length.

***** Sequence Functions for Searching

=find-if= finds the first value that satisfies a predicate.
=count= finds out how often an object appears in a sequence.
=position= tells you where an item is located.
=some= and =every= tell you if some or every value in a sequence obey a
predicate.

#+begin_src lisp
(find-if #'numberp '(a b 5 d))
;; -> 5
(count #\s "mississippi")
;; -> 4
(position #\4 "2kewl4skewl")
;; -> 5
(some #'numberp '(a b 5 d))
;; -> T
(every #'numberp '(a b 5 d))
;; -> NIL
#+end_src

***** Sequence Functions for Iterating Across a Sequence

=reduce= allows you to iterate through a sequence and reduce it down to a
single result.  =map= is like =mapcar= but it works on any sequence.
You specify the type of sequence for =map= to return by passing an extra
argument to the =map= function.  =subseq= lets you pull a subsequence out
of a larger sequence by specifying starting and ending points.  The =sort=
function lets you pass it an arbitrary function to use for sorting.  These
functions are good to get you started.  For a more exhaustive list of functions,
refer to the [[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm][Common Lisp Hyperspec]].  It's complicated, but it has its own FAQ,
[[https://www.hexstreamsoft.com/articles/getting-started-with-the-clhs/][Getting started with the Common Lisp HyperSpec]].

#+begin_src lisp
(reduce #'+ '(3 4 6 5 2))
;; -> 20

(reduce (lambda (best item)
          (if (and (evenp item) (> item best))
            item
            best))
        '(7 4 6 5 2)
        :initial-value 0)
;; -> 6 ;; the greatest even item in the list

(map 'list
  (lambda (x)
    (if (eq x #\s)
      #\S
      x))
  "this is a string")
;; -> (“(#\t #\h #\i #\S #\  #\i #\S #\  #\a #\  #\S #\t #\r #\i #\n #\g)”

(subseq "america" 2 6)
;; -> "eric"

(sort '(4 8 2 4 9 3 6) #'<)
;; -> (2 3 4 5 6 8 9)
#+end_src)

**** Creating Your Own Generic Functions with Type Predicates and =defmethod=

You can tell what type a variable has with the type predicates.  The most
frequently used are: =arrayp=, =characterp=, =consp=, =functionp=,
=hash-table-p=, =listp=, =numberp=, =stringp=, and =symbolp=.

Here's a naive way to write an add function that works on lists or numbers.

#+begin_src lisp
;; this add works with numbers or lists
;; if we aren't given two numbers or two lists, the cond returns nil
(defun add (a b)
  (cond ((and (numberp a) (numberp b)) (+ a b))
        ((and (listp a) (listp b)) (append a b))))
;; -> ADD
(add 3 4)
;; -> 7
(add '(a b) '(c d))
;; -> (A B C D)
#+end_src

A better way to do the same is /type dispatching/ via =defmethod=.  We can
extend the results of =defmethod= to new types without modifying existing types,
and the logic isn't all based around one big =cond= test.  Also, it can be
better optimized by the Lisp compiler.  =defmethod= is like =defun=, but it
allows us to write multiple functions with the same name.  The combination of
=defmethod= and =defstruct= constitutes a simple object system.

#+begin_src lisp
(defmethod add ((a number) (b number))
  (+ a b))
;; -> ADD
(defmethod add ((a list) (b list))
  (append a b))
;; -> ADD
(add 3 4)
;; -> 7
(add '(a b) '(c d))
;; -> (A B C D)
#+end_src

*** The Orc Battle Game
**** Intro to the Game

     “In the Orc Battle game, you’re a knight surrounded by 12 monsters,
     engaged in a fight to the death. With your superior wits and your
     repertoire of sword-fighting maneuvers, you must carefully strategize in
     your battle with orcs, hydras, and other nasty enemies. One wrong move
     and you may be unable to kill them all before being worn down by their
     superior numbers. Using defmethod and defstruct, let’s dispatch some
     whoop ass on these vermin!”

**** Full Code in orc-battle.lisp
**** Initialize Some Variables

#+begin_src lisp
(defparameter *player-health* nil)
(defparameter *player-agility* nil)
(defparameter *player-strength* nil)
(defparameter *monsters* nil)
(defparameter *monster-builders* nil)
(defparameter *monster-num* 12)
#+end_src

**** Main Function and Basic Game Loop

#+begin_src lisp
(defun orc-battle ()
  (init-monsters)
  (init-player)
  (game-loop)
  (when (player-dead)
    (princ "You have been killed.  Game Over."))
  (when (monsters-dead)
    (princ "Congratulations!  You have vanquished all of your foes.")))

(defun game-loop ()
  (unless (or (player-dead) (monsters-dead))
    (show-player)
    (dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))
      (unless (monsters-dead)
        (show-monsters)
        (player-attack)))
    (fresh-line)
    (map 'list
         (lambda (m)
           (or (monster-dead m) (monster-attack m)))
         *monsters*)
    (game-loop)))
#+end_src

**** Player Management Functions

#+begin_src lisp
(defun init-player ()
  (setf *player-health* 30)
  (setf *player-agility* 30)
  (setf *player-strength* 30))

(defun player-dead ()
  (<= *player-health* 0))

(defun show-player ()
  (fresh-line)
  (princ "You are a valiant knight with a health of ")
  (princ *player-health*)
  (princ ", and agility of ")
  (princ *player-agility*)
  (princ ", and a strength of ")
  (princ *player-strength*))

(defun player-attack ()
  (fresh-line)
  (princ "Attack style: [s]tab [d]ouble swing [r]oundhouse: ")
  (case (read)
    (s (monster-hit (pick-monster)
                    (+ 2 (randval (ash *player-strength* -1)))))
    (d (let ((x (randval (truncate (/ *player-strength* 6)))))
         (princ "Your double swing has a strength of ")
         (princ x)
         (fresh-line)
         (monster-hit (pick-monster) x)
         (unless (monsters-dead)
           (monster-hit (pick-monster) x))))
    (otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))
                 (unless (monsters-dead)
                   (monster-hit (random-monster) 1))))))
#+end_src

**** Helper Functions for =player-attack=

We need a way to generate random values from 1 to n, a way to pick a random
monster, and a way to let the player select a monster.

#+begin_src lisp
(defun randval (n)
  (1+ (random (max 1 n))))

(defun random-monster ()
  (let ((m (aref *monsters* (random (length *monsters*)))))
    (if (monster-dead m)
        (random-monster)
        m)))

(defun pick-monster ()
  (fresh-line)
  (princ "Monster #: ")
  (let ((x (read)))
    (if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))
        (progn (princ "That is not a valid monster number.")
               (pick-monster))
        (let ((m (aref *monsters* (1- x))))
          (if (monster-dead m)
              (progn (princ "That monster is already dead.")
                     (pick-monster))
              m)))))
#+end_src

**** Monster Management Functions

#+begin_src lisp
(defun init-monsters ()
  (setf *monsters*
        (map 'vector
             (lambda (x)
               (funcall (nth (random (length *monster-builders*))
                                     *monster-builders*)))
               (make-array *monster-num*))))

(defun monster-dead (m)
  (<= (monster-health m) 0))

(defun monsters-dead ()
  (every #'monster-dead *monsters*))

(defun show-monsters ()
  (fresh-line)
  (princ "Your foes:")
  (let ((x 0))
    (map 'list
         (lambda (m)
           (fresh-line)
           (princ "    ")
           (princ (incf x))
           (princ ". ")
           (if (monster-dead m)
               (princ "**dead**")
               (progn (princ "(Health=")
                      (princ (monster-health m))
                      (princ ") ")
                      (monster-show m))))
         *monsters*)))
#+end_src

**** The Monsters (where we're using =defmethod= and =defstructure=!)
***** Note: There's cool pictures of all these monsters in the book!
***** The Generic Monster

All monsters have a health meter that determines how many hits they take
before they die.  When we declare a slot in a structure, we can put
parentheses around the name and add a default value for that slot.
=(defstruct monster (health (randval 10)))= declares a monster structure
that has a health property that defaults to a random value from 1 to 10.
Remember, defining this structure introduces a =make-monster= function to
create entities.  We're using =defmethod= for =monster-hit= and
=monster-show= so we can customize these for different types of monsters.
Note for our monster structure =(type-of m)= will be monster.  Also,
=monster-attack= is intentionally left empty, since the generic monster
doesn't have an attack.  We'll customize this for each monster.

#+begin_src lisp
(defstruct monster (health (randval 10)))

(defmethod monster-hit (m x)
  (decf (monster-health m) x)
  (if (monster-dead m)
      (progn (princ "You killed the ")
             (princ (type-of m))
             (princ "! "))
      (progn (princ "You hit the ")
             (princ (type-of m))
             (princ ", knocking off ")
             (princ x)
             (princ " health points! "))))

(defmethod monster-show (m)
  (princ "A fierce ")
  (princ (type-of m)))

;; intentionally left empty for the generic monster
(defmethod monster-attack (m))
#+end_src

***** The Wicked Orc

"The orc is a simple foe.  He can deliver a strong attack with his club,
but otherwise he is pretty harmless.  Every orc has a club with a unique
attack level.  Orcs are best ignored, unless there are orcs with an unusually
powerful club attack that you want to cull from the herd at the beginning of a
battle."

Notice how we include all the properties from our =monster= in our =orc=.  Also
notice that the orc relies on the generic monster =monster-hit= function rather
than defining one of its own.

#+begin_src lisp
(defstruct (orc (:include monster)) (club-level (randval 8)))
(push #'make-orc *monster-builders*)

(defmethod monster-show ((m orc))
  (princ "A wicked orc with a level ")
  (princ (orc-club-level m))
  (princ " club"))

(defmethod monster-attack ((m orc))
  (let ((x (randval (orc-club-level m))))
    (princ "An orc swings his club at you and knocks off ")
    (princ x)
    (princ " of your health points.  ")
    (decf *player-health* x)))
#+end_src

***** The Malicious Hydra

"The hydra is a very nasty enemy.  It will attack you with its many heads,
which you'll need to chop off to defeat it.  The hydra's special power is that
it can grow a new head during each round of battle, which means you want to
defeat it as early as possible."

#+begin_src lisp
(defstruct (hydra (:include monster)))
(push #'make-hydra *monster-builders*)

(defmethod monster-show ((m hydra))
  (princ "A malicious hydra with ")
  (princ (monster-health m))
  (princ " heads."))

(defmethod monster-hit ((m hydra) x)
  (decf (monster-health m) x)
  (if (monster-dead m)
      (princ "The corpse of the fully decapitated and decapacitated hydra falls to the floor!")
      (progn (princ "You lop off ")
             (princ x)
             (princ " of the hydra's heads! "))))

(defmethod monster-attack ((m hydra))
  (let ((x (randval (ash (monster-health m) -1))))
    (princ "A hydra attacks you with ")
    (princ x)
    (princ " of its heads!  It also grows back one more head! ")
    (incf (monster-health m))
    (decf *player-health* x)))
#+end_src

***** The Slimy Slime Mold

"The slime mold is a unique monster.  When it attacks you, it will wrap itself
around your legs and immobilize you, letting the other bad guys finish you off.
It can also squirt goo in your face.  You must think quickly in battle to
decide if it's better to finish the slime off early in order to maintain your
agility, or ignore it to focus on more vicious foes first."

#+begin_src lisp
(defstruct (slime-mold (:include monster)) (sliminess (randval 5)))
(push #'make-slime-mold *monster-builders*)

(defmethod monster-show ((m slime-mold))
  (princ "A slime mold with a sliminess of ")
  (princ (slime-mold-sliminess m)))

(defmethod monster-attack ((m slime-mold))
  (let ((x (randval (slime-mold-sliminess m))))
    (princ "A slime mold wraps around your legs and decreases your agility by ")
    (princ x)
    (princ "!  ")
    (decf *player-agility* x)
    (when (zerop (random 2))
      (princ "It also squirts in your face, taking away a health point!")
      (decf *player-health*))))
#+end_src

***** The Cunning Brigand

"The brigand is the smartest of all your foes.  He can use his whip or slingshot
and will try to neutralize your best assets.  His attacks are not powerful, but
they are a consistent two points for every round."

Brigand uses the generic monster =monster-show=.

#+begin_src lisp
(defstruct (brigand (:include monster)))
(push #'make-brigand *monster-builders*)

(defmethod monster-attack ((m brigand))
  (let ((x (max *player-health* *player-agility* *player-strength*)))
    (cond ((= x *player-health*)
           (princ "A brigand hits you with his slingshot, taking off 2 health points!  ")
           (decf *player-health* 2))
          ((= x *player-agility*)
           (princ "A brigand catches your leg with his whip, taking off 2 agility points!  ")
           (decf *player-agility* 2))
          ((= x *player-strength* 2)
           (princ "A brigand cuts your arm with his whip, taking off 2 strength points!  ")
           (decf *player-strength* 2)))))
#+end_src

* III - Lisp is Hacking
* IV - Lisp is Science
